<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clearly's Mechabellum Voice Unit Counter Tool</title>
    <!-- Load Tailwind CSS from CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
        }
    </style>
</head>
<body class="flex flex-col items-center p-4">

    <!-- Main Container -->
    <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-2xl w-full relative">
        <!-- Version Number -->
        <span class="absolute top-4 right-4 text-xs text-gray-400">v4.0</span>
        
<h1 class="text-3xl font-bold text-center mb-4 text-sky-400">Clearly's Mechabellum Voice Unit Counter Tool</h1>
        <p class="text-center text-gray-400 mb-4">Try saying "add three friendly crawlers" or "reset counters"</p>

        <!-- Aerial Advantage Warning Banner (Initially Hidden) -->
        <div class="flex justify-center">
            <div id="aerial-warning" class="hidden inline-block bg-yellow-500 text-yellow-900 font-bold py-0.5 px-1 rounded-sm text-xs shadow-md mb-2 transition-all duration-300">
                Warning: <span id="advantage-side"></span> has an aerial advantage!
            </div>
        </div>

        <!-- Control Buttons and Status/Command Display -->
        <div class="flex flex-col md:flex-row items-center justify-center gap-1 mb-4">
            <button id="toggle-voice-btn" class="p-0.5 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-md transition duration-300 w-full md:w-auto">
                Start Listening
            </button>
            <!-- Single combined element for status and last command, now on the same line -->
            <p id="status-message" class="text-gray-400 italic text-center mt-1 md:mt-0">Press the button to begin.</p>
        </div>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-1">
            <div class="bg-red-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
                <h2 id="enemy-units-title" class="text-large mb-0 text-center">Enemy Units: 0</h2>
                <div class="text-[10px] text-gray-400 mb-0 text-center">
                    <span id="enemy-chaff-count">Chaff: 0</span> | <span id="enemy-chaff-clear-count">Chaff Clear: 0</span>
                </div>
                <ul id="enemy-units-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-white">Add enemy units via voice.</li>
                </ul>
            </div>

            <div class="bg-green-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
                <h2 id="friendly-units-title" class="text-large mb-0 text-center">Friendly Units: 0</h2>
                <div class="text-[10px] text-gray-400 mb-0 text-center">
                    <span id="friendly-chaff-count">Chaff: 0</span> | <span id="friendly-chaff-clear-count">Chaff Clear: 0</span>
                </div>
                <ul id="friendly-units-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-white">Add friendly units via voice.</li>
                </ul>
            </div>

            <!-- Counter Recommendations Section -->
            <div class="bg-gray-700 p-1 rounded-lg shadow-inner mb-1">
                <h2 class="text-large mb-1 text-orange-400">Counter Recommendations ‚öîÔ∏è</h2>
                <ul id="recommendations-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">

                    <li class="text-gray-400">Add enemy units to see counters.</li>
                </ul>
            </div>
            
            <!-- Synergies Recommendations Section -->
            <div id="synergy-recommendations-section" class="bg-gray-700 p-1 rounded-lg shadow-inner mb-1">
                <h2 class="text-large mb-1 text-purple-400">Synergy Recommendations ‚ú®</h2>
                <ul id="synergy-recommendations-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-gray-400">Add friendly units to see synergies.</li>
                </ul>
            </div>

            <div class="bg-red-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
			<h3 class="text-sm mb-1 text-white">Units to Avoid Purchasing üí∏</h3>
			    <ul id="avoid-purchasing-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-gray-400">Add enemy units to see counters.</li>
			</ul>
		</div>

		<!-- Units to Avoid -->
        <div class="bg-gray-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
			<h2 class="text-sm text-white mb-1">Your Units Being Countered</h2>
			<ul id="avoid-units-list" class="list-disc pl-5 space-y-2 text-sm">
				<li class="text-gray-400">Add friendly units to see what is being countered.</li>
			</ul>
		</div>
    </div>
        <!-- Footer -->
       <!-- Icon Legend -->
        <!-- New Boxed Icon Legend for Footer -->
        <div class="bg-gray-700 p-0 rounded-xl mt-4">
            <h3 class="text-center text-gray-300 mb-0 text-[10px] sm:text-xs">Icon Legend (relative to enemy units)</h3>
            <div class="flex flex-wrap justify-center items-center gap-x-3 gap-y-1 text-[10px] sm:text-xs">
                <div class="flex items-center space-x-0.5">
                    <span class="text-xs">üéØ</span>
                    <span>Ranged vs. Melee</span>
                </div>
                <div class="flex items-center space-x-0.5">
                    <span class="text-xs">‚¨ÜÔ∏è</span>
                    <span>Longer Range</span>
                </div>
                <div class="flex items-center space-x-0.5">
                    <span class="text-xs">‚¨áÔ∏è</span>
                    <span>Shorter Range</span>
                </div>
                <div class="flex items-center space-x-0.5">
                    <span class="text-xs">‚ÜîÔ∏è</span>
                    <span>Same Range</span>
                </div>
                <div class="flex items-center space-x-0.5">
                    <span class="text-xs">üî•</span>
                    <span>Melee vs. Ranged</span>
                </div>
                <div class="flex items-center space-x-0.5">
                    <span class="text-xs">‚öîÔ∏è</span>
                    <span>Melee vs. Melee</span>
                </div>
            </div>
        </div>
    </div>

         
    <div class="mt-8 text-center text-gray-400 text-xs">
        <p>&copy; 2025 Clearly Misunderstood  || 
        Code available on <a href="https://github.com/dsp6855/Clearly-s-Mechabellum-Voice-Unit-Counter-Tool/tree/main" class="text-indigo-400 hover:underline">GitHub</a></p>

    </div>


    <script>
        // Use an IIFE (Immediately Invoked Function Expression) to avoid global pollution.
        (function() {
		// Check for Web Speech API support
			if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
				// Hide the button and show an error message
				document.getElementById('toggle-voice-btn').style.display = 'none';
				document.getElementById('status-message').textContent = 'Sorry, voice recognition is not supported in this browser.  Try Chrome.';
				document.getElementById('status-message').style.color = '#ffcc00';
				console.error('Web Speech API not supported in this browser.');
				return; // Stop the script from running further
			}
		
            // --- DATA ---
            // A mock mechData object with a "unitCount" and "cost" property.
            const mechData = {
                "Abyss": { "category": ["titan", "air", "ranged", "splash"], "descriptions": "Titan, air, late game, single unit, 100 range, splash, targets air and ground, upkeep cost", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "range":100, "cost": 800 },
                "Arclight": { "category": ["medium", "ground", "ranged", "splash","chaff clear"], "descriptions": "Medium, ground, anti-swarm, can do anti-air, single unit, splash, 93 range", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":93, "cost": 100 },
                "Crawler": { "category": ["light", "ground", "melee","chaff"], "descriptions": "light, melee, ground, attacks ground only, 24 units, high speed", "unitCount": 24, "isAirUnit": false, "targets": ["ground"], "range":0, "cost": 100 },
                "Fang": { "category": ["light", "ground", "ranged","chaff"], "descriptions": "light, ground, all-purpose, 18 units, 75 range, targets air and ground, can hide, high speed", "unitCount": 18, "isAirUnit": false, "targets": ["air", "ground"], "range":75, "cost": 100 },
                "Farseer": { "category": ["large", "ground", "ranged", "splash"], "descriptions": "large, high speed, splash, 125 range, attack air and ground, single unit, rocket", "unitCount": 1, "isAirUnit": false, "targets": ["air", "ground"], "range":125, "cost": 300 },
                "Fire Badger": { "category": ["medium", "ground", "ranged", "splash","chaff clear"], "descriptions": "medium, anti-swarm tank, splash, 60 range, targets ground only, 3 units", "unitCount": 3, "isAirUnit": false, "targets": ["ground"], "range":60, "cost": 200 },
                "Fortress": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "giant, high damage, rocket, ground only target, 100 range, splash, slow, high hp, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":100, "cost": 400 },
                "Hacker": { "category": ["medium", "ground", "special", "ranged"], "descriptions": "hacker, ground, disables tech, 110 range, high speed", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":70, "cost": 200 },
                "Hounds": { "category": ["light", "ground", "ranged", "splash","chaff"], "descriptions": "high-speed, anti-unit, ground only, 70 range, 5 units", "unitCount": 5, "isAirUnit": false, "targets": ["ground"], "range":140, "cost": 100 },
                "Marksman": { "category": ["light", "ground", "ranged","carry"], "descriptions": "light, anti-air, targets air and ground, 140 range, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["air", "ground"], "range":115, "cost": 100 },
                "Melting Point": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "heavy, ground, anti-armor, flame, 115 range, large splash, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["air", "ground"], "range":100, "cost": 400 },
                "Mountain": { "category": ["titan", "ground", "ranged", "splash"], "descriptions": "giant, high hp, slow, ranged, 100 range, target ground only, 1 units", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":100, "cost": 800 },
                "Mustang": { "category": ["light", "ground", "ranged","chaff"], "descriptions": "light, mobile, anti-air, targets air and ground, 95 range, 12 units", "unitCount": 12, "isAirUnit": false, "targets": ["air", "ground"], "range":95, "cost": 200 },
                "Overlord": { "category": ["giant", "air", "ranged", "splash","carry"], "descriptions": "giant, anti-swarm, fire, 120 range, splash, single unit, high hp, fast", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "range":120, "cost": 500 },
                "Phantom Ray": { "category": ["medium", "air", "ranged", "splash"], "descriptions": "light, air, 65 range, high speed, single unit, splash, targets air and ground, low hp", "unitCount": 3, "isAirUnit": true, "targets": ["air", "ground"], "range":65, "cost": 200 },
                "Phoenix": { "category": ["medium", "air", "ranged", "splash","carry"], "descriptions": "medium, air, 120 range, targets air and ground, 2 units, splash, high speed", "unitCount": 2, "isAirUnit": true, "targets": ["air", "ground"], "range":110, "cost": 200 },
                "Raiden": { "category": ["giant", "air", "ranged"], "descriptions": "heavy, ground, 110 range, single unit, targets air and ground, rocket", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "range":110, "cost": 400 },
                "Rhino": { "category": ["heavy", "ground", "melee", "splash"], "descriptions": "heavy, high hp, ground, anti-armor, single unit, splash", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":0, "cost": 200 },
                "Sabertooth": { "category": ["heavy", "ground", "ranged"], "descriptions": "heavy, 90 range, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":90, "cost": 200 },
                "Sandworm": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "giant, ground, splash, single unit, burrow. Can attack air with tech upgrade.", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":0, "cost": 400 },
                "Scorpion": { "category": ["heavy", "ground", "ranged", "splash","carry"], "descriptions": "heavy, anti-swarm, big splsh, high damage, slow speed, target ground only, single unit, 100 range", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":100, "cost": 300 },
                "Sledgehammer": { "category": ["heavy", "ground", "ranged", "splash","carry"], "descriptions": "Heavy Tank, ranged, ground target, splash, slow, 95 range, 5 units", "unitCount": 5, "isAirUnit": false, "targets": ["ground"], "range":95, "cost": 200 },
                "Steel Ball": { "category": ["medium", "ground", "ranged"], "descriptions": "high-speed, anti-unit, ground only 45 range, attack grows longer attacking, 4 units", "unitCount": 4, "isAirUnit": false, "targets": ["ground"], "range":45, "cost": 200 },
                "Stormcaller": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "heavy rocket launcher, target ground only, splash, 180 range, 4 units, rockets", "unitCount": 4, "isAirUnit": false, "targets": ["ground"], "range":180, "cost": 200 },
                "Tarantula": { "category": ["heavy", "ground", "ranged", "splash","chaff clear"], "descriptions": "heavy, splash, 80 range, fast attack, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":100, "cost": 200 },
                "Typhoon": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "heavy, all purpose, splash, quick attack, 100 range, targets air and ground, 2 units", "unitCount": 2, "isAirUnit": false, "targets": ["air", "ground"], "range":100, "cost": 300 },
                "Void Eye": { "category": ["light", "ground", "special", "ranged"], "descriptions": "light, high damage, 100 range, target ground only, 3 units. Can attack air with tech upgrade.", "unitCount": 3, "isAirUnit": false, "targets": ["ground"], "range":100, "cost": 100 },
                "Vulcan": { "category": ["giant", "ground", "ranged", "splash","chaff clear"], "descriptions": "giant, anti-swarm, fire, large spash, 95 range,target ground only, single unit, high hp", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":95, "cost": 400 },
                "War Factory": { "category": ["titan", "ground", "ranged", "splash"<"chaff clear"], "descriptions": "titan, produces other units, high hp, expensive, 100 range, targets ground only, splash, slow, upkeep cost", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "range":100, "cost": 800 },
                "Wasp": { "category": ["light", "air", "ranged","chaff"], "descriptions": "light, air, 12 units, 50 range, high speed, targets air and ground, low HP", "unitCount": 12, "isAirUnit": true, "targets": ["air", "ground"], "range":50, "cost": 200 },
                "Wraith": { "category": ["heavy", "air", "ranged", "splash","chaff clear"], "descriptions": "heavy, air, single unit, 60 range, splash", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "range":60, "cost": 300 }
            };
            
            // This is the correct counters data, replacing the previous duplicate.
            const countersData = {
                "Abyss": { "weakness": ["Marksman", "Melting Point", "Mustang", "Wasp"], "strong_counter": ["Sledgehammer"], "synergizes":["Sledgehammer","Tarantula","Sabertooth"] },
                "Arclight": { "weakness": ["Fortress", "Melting Point", "Overlord", "Rhino", "Scorpion", "Steel Ball", "Stormcaller", "Vulcan", "War Factory", "Hacker"], "strong_counter": ["Crawler", "Hounds", "Mustang", "Stormcaller"], "synergizes":[] },
                "Crawler": { "weakness": ["Arclight", "Fire Badger", "Mustang", "Sledgehammer", "Vulcan", "Wraith"], "strong_counter": ["Hacker", "Marksman", "Melting Point", "Sabertooth", "Steel Ball", "Void Eye"], "synergizes":["Phantom Ray"] },
                "Fang": { "weakness": ["Crawler","Fire Badger", "Mustang", "Steel Ball", "Typhoon", "Vulcan", "Wraith"], "strong_counter": ["Fortress", "Marksman", "Mustang", "Phoenix", "Sabertooth", "Stormcaller", "Wasp"], "synergizes":["Typhoon","Marksman", "Sledgehammer","Fortress"] },
                "Farseer": { "weakness": ["Fortress", "Melting Point", "Rhino", "War Factory"], "strong_counter": ["Marksman", "Mustang", "Phantom Ray", "Phoenix", "Raiden", "Tarantula", "Hacker"], "synergizes":["Mustang"] },
                "Fire Badger": { "weakness": ["Fortress", "Overlord", "Rhino", "Sabertooth", "War Factory", "Hacker"], "strong_counter": ["Crawler", "Fang", "Hounds"], "synergizes":[] },
                "Fortress": { "weakness": ["Fang x3", "Melting Point", "Overlord", "Sandworm", "Steel Ball"], "strong_counter": ["Arclight", "Farseer", "Fire Badger", "Sabertooth", "Stormcaller", "Tarantula", "Typhoon", "Vulcan", "Rhino", "Hacker"], "synergizes":["Mustang","Fang"] },
                "Hacker": { "weakness": ["Crawler", "Marksman", "Mustang", "Scorpion", "Stormcaller", "Typhoon", "Sabertooth", "Farseer", "Fortress", "Melting Point", "Sandworm", "War Factory", "Mountain", "Phoenix", "Overlord"], "strong_counter": ["Fire Badger", "Arclight", "Steel Ball"], "synergizes":["Melting Point"] },
                "Hounds": { "weakness": ["Arclight", "Fire Badger", "Melting Point", "Overlord", "Rhino", "Scorpion", "Sledgehammer", "Steel Ball", "Tarantula", "Vulcan"], "strong_counter": [], "synergizes":[] },
                "Marksman": { "weakness": ["Crawler", "Fang", "Farseer", "Mustang", "War Factory"], "strong_counter": ["Abyss", "Melting Point", "Phantom Ray", "Phoenix", "Raiden", "Stormcaller", "Tarantula", "Hacker"], "synergizes":["Vulcan","Tarantula","Sledgehammer","Fang"] },
                "Melting Point": { "weakness": ["Crawler", "Marksman", "Phoenix", "Steel Ball"], "strong_counter": ["Abyss", "Arclight", "Farseer", "Fortress", "Hounds", "Mountain", "Overlord", "Raiden", "Rhino", "Sabertooth", "Sandworm", "Tarantula", "Typhoon", "Void Eye", "Vulcan", "War Factory", "Wraith", "Hacker"], "synergizes":["Hacker"] },
                "Mountain": { "weakness": ["Melting Point", "Overlord", "Scorpion", "Sledgehammer", "Stormcaller", "Tarantula", "Vulcan"], "strong_counter": ["Sandworm", "Rhino", "Hacker"], "synergizes":["Raiden"] },
                "Mustang": { "weakness": ["Arclight", "Fang", "Farseer", "Overlord", "Phoenix", "Rhino", "Tarantula", "Wasp"], "strong_counter": ["Abyss", "Crawler", "Fang", "Marksman", "Overlord", "Phantom Ray", "Phoenix", "Stormcaller", "Wasp", "Hacker"], "synergizes":["Fortress","Scorpion","Farseer"] },
                "Overlord": { "weakness": ["Melting Point", "Mustang", "Phoenix", "Wasp"], "strong_counter": ["Arclight", "Fire Badger", "Fortress", "Hacker", "Hounds", "Mountain", "Mustang", "Raiden", "Rhino", "Scorpion", "Steel Ball", "Sledgehammer", "Stormcaller", "Tarantula", "Vulcan", "War Factory", "Wraith"], "synergizes":["Typhoon"] },
                "Phantom Ray": { "weakness": ["Farseer", "Marksman", "Mustang", "Phoenix", "Raiden", "Typhoon", "Wasp", "Wraith"], "strong_counter": ["Wraith"], "synergizes":["Crawler"] },
                "Phoenix": { "weakness": ["Fang", "Farseer", "Marksman", "Mustang", "Wasp"], "strong_counter": ["Hacker", "Melting Point", "Mustang", "Overlord", "Phantom Ray", "Raiden", "Rhino", "Scorpion", "Sledgehammer", "Steel Ball", "Tarantula", "Typhoon", "Vulcan"], "synergizes":["Typhoon"] },
                "Raiden": { "weakness": ["Farseer", "Marksman", "Melting Point", "Overlord", "Phoenix"], "strong_counter": ["Phantom Ray", "Wraith"], "synergizes":["Mountain"] },
                "Rhino": { "weakness": ["Steel Ball", "Scorpion", "Sabertooth", "Fortress", "War Factory", "Mountain", "Phoenix", "Melting Point", "Overlord"], "strong_counter": ["Arclight", "Void Eye", "Hounds", "Mustang", "Sledgehammer", "Fire Badger", "Typhoon", "Tarantula", "Farseer", "Vulcan"], "synergizes":[] },
                "Sabertooth": { "weakness": ["Crawler", "Fang", "Fortress", "Melting Point", "Steel Ball", "War Factory"], "strong_counter": ["Fire Badger", "Typhoon", "Rhino", "Hacker"], "synergizes":[] },
                "Sandworm": { "weakness": ["Melting Point", "Mountain", "War Factory"], "strong_counter": ["Fortress", "Hacker"], "synergizes":[] },
                "Scorpion": { "weakness": ["Overlord", "Phoenix", "Wasp"], "strong_counter": ["Arclight", "Hounds", "Mountain", "Typhoon", "Void Eye", "War Factory", "Rhino", "Hacker", "Vulcan"], "synergizes":["Mustang"] },
                "Sledgehammer": { "weakness": ["Phoenix", "Vulcan", "War Factory", "Overlord", "Rhino", "Abyss"], "strong_counter": ["Crawler", "Hounds", "Mountain", "Void Eye"], "synergizes":["Marksman"] },
                "Steel Ball": { "weakness": ["Crawler", "Overlord", "Phoenix", "Hacker"], "strong_counter": ["Arclight", "Fang", "Fortress", "Hounds", "Melting Point", "Rhino", "Sabertooth", "Tarantula", "Typhoon", "Void Eye", "Vulcan"], "synergizes":[] },
                "Stormcaller": { "weakness": ["Arclight", "Fang", "Fortress", "Marksman", "Mustang", "Overlord", "Typhoon", "Vulcan"], "strong_counter": ["Arclight", "Hacker", "Mountain", "Tarantula"], "synergizes":[] },
                "Tarantula": { "weakness": ["Farseer", "Fortress", "Marksman", "Melting Point", "Overlord", "Phoenix", "Steel Ball", "Stormcaller", "War Factory", "Rhino"], "strong_counter": ["Hounds", "Mountain", "Mustang", "Void Eye"], "synergizes":[] },
                "Typhoon": { "weakness": ["Fortress", "Melting Point", "Phoenix", "Sabertooth", "Scorpion", "Steel Ball", "War Factory"], "strong_counter": ["Fang", "Phantom Ray", "Stormcaller", "Void Eye", "Wraith", "Hacker"], "synergizes":["Phoenix","Fang","Overlord"] },
                "Void Eye": { "weakness": ["Crawler", "Melting Point", "Rhino", "Scorpion", "Sledgehammer", "Steel Ball", "Tarantula", "Typhoon", "Vulcan"], "strong_counter": [], "synergizes":[] },
                "Vulcan": { "weakness": ["Fortress", "Melting Point", "Overlord", "Phoenix", "Steel Ball", "Rhino", "Scorpion"], "strong_counter": ["Arclight", "Crawler", "Fang", "Hounds", "Mountain", "Sledgehammer", "Stormcaller", "Void Eye"], "synergizes":["Marksman"] },
                "War Factory": { "weakness": ["Melting Point", "Overlord", "Scorpion"], "strong_counter": ["Arclight", "Farseer", "Fire Badger", "Hacker", "Marksman", "Rhino", "Sabertooth", "Sandworm", "Sledgehammer", "Tarantula", "Typhoon", "Rhino", "Hacker"], "synergizes":[] },
                "Wasp": { "weakness": ["Fang", "Mustang", "Wraith"], "strong_counter": ["Abyss", "Mustang", "Overlord", "Phantom Ray", "Phoenix", "Scorpion"], "synergizes":[] },
                "Wraith": { "weakness": ["Marksman","Melting Point", "Overlord", "Phantom Ray", "Raiden", "Typhoon"], "strong_counter": ["Crawler", "Fang", "Phantom Ray", "Wasp"], "synergizes":[] }
            };
            
            // This loop adds each unit to its own weakness array for complete counter logic.
            for (const unit in countersData) {
                if (countersData.hasOwnProperty(unit)) {
                    if (!countersData[unit].weakness.includes(unit)) {
                        countersData[unit].weakness.push(unit);
                    }
                }
            }
            
            // Map for converting spoken numbers to integers
            const numberWords = {
                'one': 1, 'an':1, 'a':1, 'two': 2, 'to':2, 'too':2, 'three': 3, 'through':3, 'four': 4, 'for':4, 'five': 5,
                'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10
            };
            
            // Map for handling common voice recognition misrecognitions or alternate names
            const nameMap = {
				'of this': 'Abyss',
                'a best': 'Abyss',
				'abyss': 'Abyss',
                'abysses': 'Abyss',
                'arc light': 'Arclight',
                'arc lines': 'Arclight',
                'arclights': 'Arclight',
                'Ark light': 'Arclight',
                'ark lights': 'Arclight',
                'arcolite': 'Arclight',
                'arc lights': 'Arclight',
                'crawlers': 'Crawler',
                'crawler': 'Crawler',
                'growler': 'Crawler',
                'growlers': 'Crawler',
                'fangs': 'Fang',
                'things': 'Fang',
                'farseers': 'Farseer',
                'farsier': 'Farseer',
                'farce here': 'Farseer',
                'Farsiers': 'Farseer',
                'Farsier': 'Farseer',
                'fire badger': 'Fire Badger',
                'five Sears': 'Farseer',
                'farts here': 'Farseer',
                'far sear': 'Farseer',
                'fars here': 'Farseer',
                'fortresses': 'Fortress',
				'fortress': 'Fortress',
				'fire badgers': 'Fire Badger',
                'hackers': 'Hacker',
                'hounds': 'Hounds',
                'hound': 'Hounds',
                'hand': 'Hounds',
                'marksmen': 'Marksman',
                'marskmans': 'Marksman',
                'melting points': 'Melting Point', 
                'melting point': 'Melting Point', 
                'melting': 'Melting Point', 
                'mountains': 'Mountain',
                'mustangs': 'Mustang',
                'overlords': 'Overlord',
                'over lords': 'Overlord',
                'over lord': 'Overlord',
                'phantom rays': 'Phantom Ray',
                'phantom ray': 'Phantom Ray',
                'phoenixes': 'Phoenix',
                'raidens': 'Raiden',
                'ratings': 'Raiden',
                'rhinos': 'Rhino',
                'right now': 'Rhino',
                'sandworms': 'Sandworm',
                'sand worms': 'Sandworm',
                'sand worm': 'Sandworm',
                'sabertooths': 'Sabertooth',
                'saber tooth': 'Sabertooth',
                'saber tooths': 'Sabertooth',
                'scorpions': 'Scorpion',
                'sledgehammer': 'Sledgehammer',
                'sledgehammers': 'Sledgehammer',
                'sledge hammer': 'Sledgehammer',
                'sledge hammers': 'Sledgehammer',
                'steel balls': 'Steel Ball',
                'steel ball': 'Steel Ball',
                'stool balls': 'Steel Ball',
                'still balls': 'Steel Ball',
                'stormcallers': 'Stormcaller',
                'storm collars': 'Stormcaller',
                'storm coller': 'Stormcaller',
                'storm collars': 'Stormcaller',
                'storm collar': 'Stormcaller',
                'tarantulas': 'Tarantula',
                'thing': 'Fang',
                'typhoons': 'Typhoon',
                'void eyes': 'Void Eye',
                'void eye': 'Void Eye',
                'void I': 'Void Eye',
                'void i': 'Void Eye',
                'vulcans': 'Vulcan',
				'war factory': 'War Factory',
                'war factories': 'War Factory',
                'war factoring': 'War Factory',
                'War Factory': 'War Factory',
                'work Factory': 'War Factory',
                'more Factory': 'War Factory',
                'more factories': 'War Factory',
                'wasps': 'Wasp',
                'wraith': 'Wraith',
                'wraiths': 'Wraith',
                'wraths': 'Wraith'
            };

            const friendlyTerms = ['friendly', 'friend', 'friends', 'our', 'ally', 'allied', 'my', 'me', 'us', 'team'];
            const enemyTerms = ['enemy', 'enemies', 'enemy\'s', 'foe', 'opponent', 'their', 'them', 'opposing', 'opponent\'s', 'opponents'];
            const addTerms = ['ad', 'at', 'bad', 'had', 'i had', 'add', 'give']; //i had being two words is handled at processCommand function.
            const removeTerms = ['remove', 'delete', 'subtract', 'minus', '-', 'take', 'less'];

            // --- STATE ---
            let friendlyUnits = {};
			let enemyUnits = {};
			let isListening = false;
			let recognition = null;
			let finalTranscript = '';
			let lastTranscript = '';

            // --- DOM ELEMENTS ---
            const toggleButton = document.getElementById('toggle-voice-btn');
            const statusMessage = document.getElementById('status-message');
            const friendlyUnitsList = document.getElementById('friendly-units-list');
            const enemyUnitsList = document.getElementById('enemy-units-list');
            const friendlyUnitsTitle = document.getElementById('friendly-units-title');
            const enemyUnitsTitle = document.getElementById('enemy-units-title');
            const recommendationsList = document.getElementById('recommendations-list');
            const aerialWarning = document.getElementById('aerial-warning');
            const advantageSideSpan = document.getElementById('advantage-side');
            const avoidUnitsList = document.getElementById('avoid-units-list'); 
            const synergyRecommendationsList = document.getElementById('synergy-recommendations-list'); 
            const avoidPurchasingList = document.getElementById('avoid-purchasing-list'); 
            const friendlyChaffCountSpan = document.getElementById('friendly-chaff-count');
            const friendlyChaffClearCountSpan = document.getElementById('friendly-chaff-clear-count');
            const enemyChaffCountSpan = document.getElementById('enemy-chaff-count');
            const enemyChaffClearCountSpan = document.getElementById('enemy-chaff-clear-count');

            // --- FUNCTIONS ---
            /**
             * Renders the current friendly and enemy units in their respective lists.
             */
            const updateUnitsDisplay = () => {
                friendlyUnitsList.innerHTML = '';
                enemyUnitsList.innerHTML = '';

                let friendlyCount = 0;
                let friendlyChaffCount = 0;
                let friendlyChaffClearCount = 0;
                for (const unit in friendlyUnits) {
                    if (friendlyUnits[unit] > 0) {
                        const li = document.createElement('li');
                        li.textContent = `${unit.charAt(0).toUpperCase() + unit.slice(1)} x${friendlyUnits[unit]}`;
                        friendlyUnitsList.appendChild(li);
                        friendlyCount += friendlyUnits[unit];
                        if (mechData[unit] && mechData[unit].category && mechData[unit].category.includes("chaff")) {
                       // if (mechData[unit] && mechData[unit].category === "chaff") {
                            friendlyChaffCount += friendlyUnits[unit];
                        }
                        if (mechData[unit] && mechData[unit].category && mechData[unit].category.includes("chaff clear")) {
                        //if (mechData[unit] && mechData[unit].category === "chaff clear") {
                            friendlyChaffClearCount += friendlyUnits[unit];
                        }
                    }
                }
                friendlyUnitsTitle.textContent = `Friendly Units: ${friendlyCount}`;
                friendlyChaffCountSpan.textContent = `Chaff: ${friendlyChaffCount}`;
                friendlyChaffClearCountSpan.textContent = `Chaff Clear: ${friendlyChaffClearCount}`;

                let enemyCount = 0;
                let enemyChaffCount = 0;
                let enemyChaffClearCount = 0;
                for (const unit in enemyUnits) {
                    if (enemyUnits[unit] > 0) {
                        const li = document.createElement('li');
                        li.textContent = `${unit.charAt(0).toUpperCase() + unit.slice(1)} x${enemyUnits[unit]}`;
                        enemyUnitsList.appendChild(li);
                        enemyCount += enemyUnits[unit];
                        //if (mechData[unit] && mechData[unit].category === "chaff") {
                        if (mechData[unit] && mechData[unit].category && mechData[unit].category.includes("chaff")) {
                            enemyChaffCount += enemyUnits[unit];
                        }
                        //if (mechData[unit] && mechData[unit].category === "chaff clear") {
                        if (mechData[unit] && mechData[unit].category && mechData[unit].category.includes("chaff clear")) {
                            enemyChaffClearCount += enemyUnits[unit];
                        }
                    }
                }
                enemyUnitsTitle.textContent = `Enemy Units: ${enemyCount}`;
                enemyChaffCountSpan.textContent = `Chaff: ${enemyChaffCount}`;
                enemyChaffClearCountSpan.textContent = `Chaff Clear: ${enemyChaffClearCount}`;
            };
            
            /**
             * Calculates and updates the counter totals.
             */
            const updateCounterCalculations = () => {
                let friendlyUnitGroupsTotal = 0;
                let enemyUnitGroupsTotal = 0;

                // Calculate total counter value for friendly units (count of groups)
                Object.keys(friendlyUnits).forEach(unitName => {
                    const quantity = friendlyUnits[unitName];
                    friendlyUnitGroupsTotal += quantity;
                });
                
                // Calculate total enemy units for display (count of groups)
                Object.keys(enemyUnits).forEach(unitName => {
                    enemyUnitGroupsTotal += enemyUnits[unitName];
                });

                // Update the UI with the totals
                friendlyUnitsTitle.textContent = `Friendly Units: ${friendlyUnitGroupsTotal}`;
                enemyUnitsTitle.textContent = `Enemy Units: ${enemyUnitGroupsTotal}`;
            };
            
            /** Begin renderRecommendations function
/**
 * Renders all three recommendation lists:
 * 1. Counter recommendations based on enemy units.
 * 2. Friendly units to avoid due to enemy counters.
 * 3. Units to avoid purchasing against the enemy composition.
 *
 * This function performs all necessary calculations and rendering in one place.
 * It is a complete replacement for the previous `renderRecommendations` function.
 */
const renderRecommendations = () => {
    // Clear all recommendation lists to prevent duplicates on each call
    const recommendationsList = document.getElementById('recommendations-list');
    const avoidUnitsList = document.getElementById('avoid-units-list');
    const avoidPurchasingList = document.getElementById('avoid-purchasing-list');

    recommendationsList.innerHTML = '';
    avoidUnitsList.innerHTML = '';
    avoidPurchasingList.innerHTML = '';

    const enemyUnitNames = Object.keys(enemyUnits);

    // If there are no enemy units, display placeholder messages and exit
    if (enemyUnitNames.length === 0) {
        recommendationsList.innerHTML = '<li class="text-gray-400 text-sm">Add enemy units to see counters.</li>';
        avoidUnitsList.innerHTML = '<li class="text-gray-400 text-sm">Add friendly units to see which to avoid.</li>';
        avoidPurchasingList.innerHTML = '<li class="text-gray-400 text-sm">Add enemy units to see which to avoid purchasing.</li>';
        return;
    }

    // --- Core Logic: Counter Calculation and Data Structuring ---
    const recommendationsData = [];
    // Create a mutable copy of friendly units to "spend" as counters
    const friendlyUnitsToAllocate = { ...friendlyUnits };
    
    // Log the contents of friendlyUnits before starting the main loop
    console.log('Contents of friendlyUnits:', friendlyUnits);
    
    // Get the keys and log them
    const friendlyUnitNamesToLog = Object.keys(friendlyUnits);
    console.log('Contents of friendlyUnitNames:', friendlyUnitNamesToLog);


    enemyUnitNames.forEach(enemyUnitName => {
        const enemyGroups = enemyUnits[enemyUnitName] || 0;
        const weaknesses = countersData[enemyUnitName]?.weakness || [];
        const enemyRange = mechData[enemyUnitName]?.range || 0;

        let groupsCountered = 0;
        const counteringUnits = {};

        // An array to store all potential counters, including `x` modifiers
        const potentialCounters = weaknesses.map(counter => {
            const parts = counter.split(' x');
            const unitName = parts[0].trim();
            const count = parts.length > 1 ? parseInt(parts[1], 10) : 1;
            const cost = mechData[unitName]?.cost || Infinity;
            const range = mechData[unitName]?.range || 0;
            return { unitName, count, cost, range };
        });

        // Sort potential counters by number of friendly groups (descending) to use larger groups first
        potentialCounters.sort((a, b) => (friendlyUnitsToAllocate[b.unitName] || 0) - (friendlyUnitsToAllocate[a.unitName] || 0));

        // Allocate friendly units to counter this enemy unit, consuming them as they are used
        for (const counter of potentialCounters) {
            // Check if there are friendly units of this type available to allocate
            const availableFriendlyUnits = friendlyUnitsToAllocate[counter.unitName] || 0;
            if (availableFriendlyUnits > 0) {
                // Calculate how many of this friendly unit are needed to counter one enemy group
                const friendlyUnitsPerEnemy = counter.count;

                // How many enemy groups can we counter with our available friendly units of this type?
                const counterableGroups = Math.floor(availableFriendlyUnits / friendlyUnitsPerEnemy);

                // How many enemy groups do we still need to counter?
                const remainingEnemyGroups = enemyGroups - groupsCountered;

                // Take the smaller of what we can counter and what we need to counter
                const groupsToAllocate = Math.min(counterableGroups, remainingEnemyGroups);
                
                if (groupsToAllocate > 0) {
                    groupsCountered += groupsToAllocate;
                    const usedFriendlyUnits = groupsToAllocate * friendlyUnitsPerEnemy;
                    
                    // Track how many friendly units were used to counter this enemy unit
                    if (counteringUnits[counter.unitName]) {
                        counteringUnits[counter.unitName] += usedFriendlyUnits;
                    } else {
                        counteringUnits[counter.unitName] = usedFriendlyUnits;
                    }

                    // Reduce the available friendly units
                    friendlyUnitsToAllocate[counter.unitName] -= usedFriendlyUnits;
                }
            }

            if (groupsCountered >= enemyGroups) {
                break; // Stop allocating once this enemy unit is fully countered
            }
        }

        const uncounteredGroups = enemyGroups - groupsCountered;
        const isCountered = uncounteredGroups <= 0;

        // If not fully countered, determine which units are needed
        const neededUnits = [];
        if (!isCountered) {
            // Find all potential counters for this enemy unit
            const allAvailableCounters = weaknesses.map(counter => {
                const parts = counter.split(' x');
                const unitName = parts[0].trim();
                const count = parts.length > 1 ? parseInt(parts[1], 10) : 1;
                const cost = mechData[unitName]?.cost || Infinity;
                const range = mechData[unitName]?.range || 0;
                return { unitName, count, cost, range, enemyRange };
            });

            // Sort new counters to recommend by range and then cost
            allAvailableCounters.sort((a, b) => {
                const rangeA_advantage = a.range > a.enemyRange;
                const rangeB_advantage = b.range > b.enemyRange;

                if (rangeA_advantage && !rangeB_advantage) return -1;
                if (!rangeA_advantage && rangeB_advantage) return 1;

                if (a.range === 0 && b.range !== 0) return 1;
                if (a.range !== 0 && b.range === 0) return -1;

                return a.cost - b.cost;
            });

            allAvailableCounters.forEach(counter => {
                neededUnits.push(counter);
            });
        }


        recommendationsData.push({
            enemyUnitName,
            enemyGroups,
            groupsCountered,
            uncounteredGroups,
            isCountered,
            counteringUnits,
            neededUnits,
            enemyRange
        });
    });

    // --- Sort the recommendations ---
    // Uncountered units first, then fully countered units
    recommendationsData.sort((a, b) => {
        if (a.isCountered && !b.isCountered) return 1;
        if (!a.isCountered && b.isCountered) return -1;
        
        // Secondary sort: for uncountered, show those with more uncountered groups first
        if (!a.isCountered && !b.isCountered) {
            return b.uncounteredGroups - a.uncounteredGroups;
        }

        // Tertiary sort: for countered, no specific order needed, but for consistency maybe by cost or alphabetical
        return a.enemyUnitName.localeCompare(b.enemyUnitName);
    });


    // --- Render the sorted data to the UI ---
    recommendationsData.forEach(item => {
        const li = document.createElement('li');
        // Compact styling: changed p-2 to p-1, mb-2 to mb-1
        li.classList.add('p-1', 'rounded-md', 'mb-1', 'shadow-sm', 'border');

        let statusText = '';
        let statusClass = '';

        if (item.isCountered) {
            statusText = 'Countered! ‚úÖ';
            statusClass = 'bg-green-700 border-green-500';
            const counteringMessage = Object.keys(item.counteringUnits).map(unitName => {
                const quantity = item.counteringUnits[unitName];
                const totalCost = quantity * (mechData[unitName]?.cost || 0);
                return `${quantity} ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ($${totalCost})`;
            }).join(', ');
            
            li.innerHTML = `
                <div class="flex justify-between items-center mb-0.5">
                    <span class="text-sm text-white">${item.enemyUnitName.charAt(0).toUpperCase() + item.enemyUnitName.slice(1)} x${item.enemyGroups}</span>
                    <span class="text-xs px-1 py-0.5 rounded-full ${statusClass}">${statusText}</span>
                </div>
                <p class="text-xs text-gray-300">Countered by: ${counteringMessage}</p>
            `;
        } else {
            statusText = 'Needs Counters ‚ùå';
            statusClass = 'bg-red-700 border-red-500';

            const neededUnitsHtml = item.neededUnits.map(unit => {
                const requiredUnits = unit.count * item.uncounteredGroups;
                const totalCost = requiredUnits * (mechData[unit.unitName]?.cost || 0);
                const counterRange = mechData[unit.unitName]?.range || 0;
                const enemyRange = mechData[item.enemyUnitName]?.range || 0;
                let rangeIcon = '';

                // Corrected logic for icons
                if (counterRange > 0 && enemyRange === 0) {
                    rangeIcon = 'üéØ'; // Ranged vs Melee
                } else if (counterRange > 0 && enemyRange > 0) {
                    if (counterRange > enemyRange) {
                        rangeIcon = '‚¨ÜÔ∏è'; // Longer Range
                    } else if (counterRange < enemyRange) {
                        rangeIcon = '‚¨áÔ∏è'; // Shorter Range
                    } else {
                        rangeIcon = '‚ÜîÔ∏è'; // Same Range
                    }
                } else if (counterRange === 0 && enemyRange > 0) {
                    rangeIcon = 'üî•'; // Melee vs Ranged
                } else if (counterRange === 0 && enemyRange === 0) {
                    rangeIcon = '‚öîÔ∏è'; // Melee vs Melee
                }
                
                return `
                    <li class="flex items-center space-x-1">
                        <span class="text-xs">${unit.unitName.charAt(0).toUpperCase() + unit.unitName.slice(1)} x${requiredUnits} ($${totalCost})</span>
                        <span class="text-sm">${rangeIcon}</span>
                    </li>
                `;
            }).join('');

            li.innerHTML = `
                <div class="flex justify-between items-center mb-0.5">
                    <span class="text-sm text-white">${item.enemyUnitName.charAt(0).toUpperCase() + item.enemyUnitName.slice(1)} x${item.enemyGroups}</span>
                    <span class="text-xs px-1 py-0.5 rounded-full ${statusClass}">${statusText}</span>
                </div>
                <p class="text-xs text-gray-300">Needed to counter **${item.uncounteredGroups}** more groups:</p>
                <ul class="mt-1 space-y-0.5">${neededUnitsHtml}</ul>
            `;
        }
        recommendationsList.appendChild(li);
    });

    // --- "Your Units Being Countered" section ---
    const friendlyUnitNames = Object.keys(friendlyUnits);

    if (friendlyUnitNames.length === 0) {
        avoidUnitsList.innerHTML = '<li class="text-gray-400 text-sm">Add friendly units to see which to avoid.</li>';
    } else {
        const unitsToAvoid = {};
        const lowerCaseEnemyUnitNames = Object.keys(enemyUnits).map(name => name.toLowerCase());

        // Create a case-insensitive map of countersData for reliable lookup
        const lowercaseCountersData = {};
        Object.keys(countersData).forEach(key => {
            lowercaseCountersData[key.toLowerCase()] = countersData[key];
        });

        friendlyUnitNames.forEach(friendlyUnitName => {
            // FIX: Use the case-insensitive map for the lookup
            const counteredByUnits = lowercaseCountersData[friendlyUnitName.toLowerCase()]?.weakness || [];
            
            // Log the contents of counteredByUnits for each friendly unit
            console.log(`Contents of counteredByUnits for ${friendlyUnitName}:`, counteredByUnits);

            // This part was already correct, ensuring case-insensitive comparison
            const foundCounters = counteredByUnits.filter(counteredByName => lowerCaseEnemyUnitNames.includes(counteredByName.toLowerCase()));
            if (foundCounters.length > 0) {
                unitsToAvoid[friendlyUnitName] = foundCounters;
            }
        });

        // Log the contents of Object.keys(unitsToAvoid) after the loop
        console.log('Contents of Object.keys(unitsToAvoid):', Object.keys(unitsToAvoid));

        if (Object.keys(unitsToAvoid).length === 0) {
            avoidUnitsList.innerHTML = '<li class="text-gray-400 text-sm">No friendly units are weak against enemy units.</li>';
        } else {
            const sortedUnitsToAvoid = Object.keys(unitsToAvoid).sort((a, b) => {
                return unitsToAvoid[b].length - unitsToAvoid[a].length;
            });
            
            const maxCounters = unitsToAvoid[sortedUnitsToAvoid[0]]?.length || 0;
            const mostCounteredUnits = sortedUnitsToAvoid.filter(unit => unitsToAvoid[unit].length === maxCounters);

            avoidUnitsList.innerHTML = '';
            mostCounteredUnits.forEach(unitToAvoid => {
                const li = document.createElement('li');
                li.classList.add('p-0', 'rounded-md', 'mb-0', 'shadow-sm', 'border', 'bg-red-700', 'border-red-500');
                const counteringUnits = unitsToAvoid[unitToAvoid].join(', ');
                li.innerHTML = `<span class="text-sm text-white">${unitToAvoid.charAt(0).toUpperCase() + unitToAvoid.slice(1)}</span><span class="text-xs px-1 py-0.5 rounded-full bg-red-800 text-white"> weak against: ${counteringUnits}</span>`;
                avoidUnitsList.appendChild(li);
            });
        }
    }

    // --- New section for "Units to Avoid Purchasing" ---
    const allUnits = Object.keys(mechData);
    const unitsToAvoidPurchasing = {};
    if (enemyUnitNames.length > 0) {
        allUnits.forEach(unitName => {
            const unitWeaknesses = countersData[unitName]?.weakness || [];
            Object.keys(enemyUnits).forEach(enemyUnitName => {
                const isWeak = unitWeaknesses.some(weakness => {
                    const parts = weakness.split(' x');
                    return parts[0].trim() === enemyUnitName;
                });
                if (isWeak) {
                    if (!unitsToAvoidPurchasing[unitName]) {
                        unitsToAvoidPurchasing[unitName] = [];
                    }
                    if (!unitsToAvoidPurchasing[unitName].includes(enemyUnitName)) {
                        unitsToAvoidPurchasing[unitName].push(enemyUnitName);
                    }
                }
            });
        });
    }

    if (Object.keys(unitsToAvoidPurchasing).length === 0) {
        avoidPurchasingList.innerHTML = '<li class="text-gray-400 text-sm">No units to avoid purchasing against this enemy composition.</li>';
    } else {
        const sortedAvoidPurchasing = Object.keys(unitsToAvoidPurchasing).sort((a, b) => {
            return unitsToAvoidPurchasing[b].length - unitsToAvoidPurchasing[a].length;
        });
        
        sortedAvoidPurchasing.forEach(unitToAvoid => {
            const li = document.createElement('li');
            // Compact styling: changed p-2 to p-1, mb-2 to mb-1
            li.classList.add('p-1', 'rounded-md', 'mb-1', 'shadow-sm', 'border', 'bg-red-700', 'border-red-500');
            const counteringUnits = unitsToAvoidPurchasing[unitToAvoid].join(', ');
            li.innerHTML = `<span class="text-sm text-white">${unitToAvoid.charAt(0).toUpperCase() + unitToAvoid.slice(1)}</span><span class="text-xs px-1 py-0.5 rounded-full bg-red-800 text-white"> weak against: ${counteringUnits}</span>`;
            avoidPurchasingList.appendChild(li);
        });
    }
};

            // end renderRecommendations function

            /** Begin Synergy Recommendations function
            /** Begin Synergy Recommendations function
             * Renders a list of synergy recommendations, now with updated sorting logic.
             * The list is sorted by:
             * 1. Uncountered synergized units first.
             * 2. Units that synergize with more friendly units (descending).
             * 3. Least expensive units (ascending) in case of a tie.
             */
            const renderSynergyRecommendations = () => {
                // Clear any existing recommendations from the list
                synergyRecommendationsList.innerHTML = '';
                const friendlyUnitNames = Object.keys(friendlyUnits);

                // If there are no friendly units, display the default message and exit.
                if (friendlyUnitNames.length === 0) {
                    synergyRecommendationsList.innerHTML = '<li class="text-gray-400">Add friendly units to see synergies.</li>';
                    return;
                }

                const recommendations = {};

                // First Pass: Find all potential synergy units based on friendly units.
                friendlyUnitNames.forEach(friendlyUnitName => {
                    // Normalize the unit name to remove the " x#" suffix before lookup.
                    const normalizedFriendlyUnitName = friendlyUnitName.toLowerCase().replace(/\s?x\d+$/, '');
                    
                    const dataKey = Object.keys(countersData).find(key => key.toLowerCase() === normalizedFriendlyUnitName.toLowerCase());
                    if (!dataKey) return;

                    const synergies = countersData[dataKey]?.synergizes || [];

                    synergies.forEach(synergyUnitName => {
                        if (!recommendations[synergyUnitName]) {
                            recommendations[synergyUnitName] = {
                                synergizingWith: [],
                            };
                        }
                        recommendations[synergyUnitName].synergizingWith.push(normalizedFriendlyUnitName);
                    });
                });

                // If no synergies were found after the first pass, display a message and exit.
                if (Object.keys(recommendations).length === 0) {
                    synergyRecommendationsList.innerHTML = '<li class="text-gray-400">No synergy recommendations at this time.</li>';
                    return;
                }

                // Convert the recommendations object into an array for easier sorting
                const synergyDataList = Object.keys(recommendations).map(synergyUnit => {
                    const synergizingWith = recommendations[synergyUnit].synergizingWith;
                    const dataKey = Object.keys(countersData).find(key => key.toLowerCase() === synergyUnit.toLowerCase());
                    const enemyCounters = countersData[dataKey]?.weakness || [];
                    
                    // --- REVISED FIX START ---
                    // Normalize the enemy unit key before checking for a counter to ensure accurate matching.
                    const isCountered = enemyCounters.some(counterUnit => {
                        return Object.keys(enemyUnits).some(enemyKey => {
                            // Normalize both the enemyKey and the counterUnit for a reliable comparison.
                            const normalizedEnemyKey = enemyKey.toLowerCase().replace(/\s?x\d+$/, '');
                            return normalizedEnemyKey === counterUnit.toLowerCase();
                        });
                    });
                    // --- REVISED FIX END ---

                    const unitCost = mechData[synergyUnit]?.cost || Infinity;

                    return {
                        synergyUnit,
                        synergizingWith,
                        isCountered,
                        unitCost
                    };
                });

                // Sort the synergy recommendations based on the new logic
                synergyDataList.sort((a, b) => {
                    // Tier 1: Prioritize uncountered units (false comes before true)
                    if (a.isCountered !== b.isCountered) {
                        return a.isCountered ? 1 : -1;
                    }

                    // Tier 2: Units that synergize with more friendly units (descending)
                    if (a.synergizingWith.length !== b.synergizingWith.length) {
                        return b.synergizingWith.length - a.synergizingWith.length;
                    }

                    // Tier 3: Least expensive units (ascending)
                    return a.unitCost - b.unitCost;
                });

                // Loop through the sorted array and render the recommendations
                synergyDataList.forEach(unitData => {
                    const { synergyUnit, synergizingWith, isCountered } = unitData;

                    const li = document.createElement('li');
                    let statusText = '';
                    let statusClass = '';

                    if (isCountered) {
                        statusText = 'Caution ‚ö†Ô∏è';
                        statusClass = 'bg-yellow-700 text-yellow-200 border-yellow-500';
                    } else {
                        statusText = 'Strong Synergy ‚úÖ';
                        statusClass = 'bg-purple-700 text-purple-200 border-purple-500';
                    }

                    li.classList.add('p-1', 'rounded-md', 'mb-1', 'shadow-sm', 'border', ...statusClass.split(' '));
                    
                    const synergizingWithText = synergizingWith.map(unit => {
                        const friendlyKey = Object.keys(friendlyUnits).find(key => key.toLowerCase().replace(/\s?x\d+$/, '') === unit.toLowerCase());
                        return `${friendlyKey.charAt(0).toUpperCase() + friendlyKey.slice(1)}`;
                    }).join(', ');

                    const synergyHtml = `
                        <div class="flex justify-between items-center mb-0">
                            <span class="text-white">${synergyUnit.charAt(0).toUpperCase() + synergyUnit.slice(1)}</span>
                            <span class="text-xs px-2 py-0.5 rounded-full ${statusClass}">${statusText}</span>
                        </div>
                        <p class="text-xs text-gray-300">Synergizes with: ${synergizingWithText}</p>
                    `;

                    li.innerHTML = synergyHtml;
                    synergyRecommendationsList.appendChild(li);
                });
            };
            // end Synergy Recommendations function

            /**
             * Checks for and displays warnings related to aerial advantage.
             */
            const checkAerialAdvantage = () => {
                let friendlyAirUnits = false;
                let friendlyAntiAirUnits = false;
                let enemyAirUnits = false;
                let enemyAntiAirUnits = false;
                const aerialWarning = document.getElementById('aerial-warning');
                const advantageSideSpan = document.getElementById('advantage-side');
                
                // Check friendly units for air and anti-air capability
                for (const unit in friendlyUnits) {
                    if (mechData[unit]?.isAirUnit) {
                        friendlyAirUnits = true;
                    }
                    if (mechData[unit]?.targets.includes("air")) {
                        friendlyAntiAirUnits = true;
                    }
                }

                // Check enemy units for air and anti-air capability
                for (const unit in enemyUnits) {
                    if (mechData[unit]?.isAirUnit) {
                        enemyAirUnits = true;
                    }
                    if (mechData[unit]?.targets.includes("air")) {
                        enemyAntiAirUnits = true;
                    }
                }
                
                // Reset visibility for the main aerial advantage banner
                aerialWarning.classList.add('hidden');

                // Condition 1: Check for a clear aerial advantage (e.g., air units with no opposing anti-air)
                if (friendlyAirUnits && !enemyAntiAirUnits) {
                    advantageSideSpan.textContent = 'Friendly Side';
                    aerialWarning.classList.remove('hidden');
                } else if (enemyAirUnits && !friendlyAntiAirUnits) {
                    advantageSideSpan.textContent = 'Enemy Side';
                    aerialWarning.classList.remove('hidden');
                }

                // This message is added to the statusMessage div, but only
                // if there are enemy units present.
                if (Object.keys(enemyUnits).length > 0 && !enemyAntiAirUnits) {
                    statusMessage.innerHTML += ' <br><span class="text-yellow-400 text-xs">(Enemy has no anti-air, consider adding air units!)</span>';
                }
            };
            // end of aerial advantage function

            /**
             * Processes a recognized voice command to add or remove a unit.
             */
            const processCommand = (command) => {
                // Convert the entire command to lowercase to handle case variations.
                const commandLower = command.toLowerCase();
                const commandWords = commandLower.split(' ');
                let action = '';
                let unitType = '';
                let unitName = '';
                let quantity = 1;
                let commandSplice=1;    

                // Handle the reset command first as a special case
                if (commandLower.trim() === 'reset counters') {
                    friendlyUnits = {};
                    enemyUnits = {};
                    updateUnitsDisplay();
                    updateCounterCalculations();
                    renderRecommendations();
                    renderSynergyRecommendations();
                    checkAerialAdvantage();
                    statusMessage.textContent = 'Counters have been reset.';
                    console.log('Counters have been reset.');
                    return;
                }

                // Update the last command display
                statusMessage.textContent = `Command: "${command}"`;
                // Check for action (add, remove)
                action = commandWords[0];
                if (action==='i') { action += ' ' + commandWords[1]; } // Handle "I had" case 
                // Handle common misrecognitions for "add"
                if (addTerms.includes(action)) {
                    action = 'add';
                    // splice off 2 words if the action is "i had"
                    if (commandWords[0].toLowerCase()==='i' && commandWords[1].toLowerCase()==='had') {
                        commandSplice=2; // If the action word is actually two words, remove both from the unit name search
                        action = 'add';
                 }
                // Handle synonyms for removing a unit
                } else if (removeTerms.includes(action)) {
                    action = 'remove';  
                // Default to add if no valid action is found, idea is this is the most common command
                } else {
                    console.log(`Unknown action: ${action}`);
                    
                    statusMessage.textContent += ' (' + action + ' unknown action)';
                    action = 'add'; 
                    commandSplice=0; // If no action word, don't remove the first word as it might be part of the unit name
                }

                // Find the quantity and unit type
                let wordsAfterAction = commandWords.slice(commandSplice);
                
                // Look for a number word or digit
                const numberIndex = wordsAfterAction.findIndex(word => !isNaN(parseInt(word)) || numberWords[word]);
                if (numberIndex !== -1) {
                    const numberWord = wordsAfterAction[numberIndex];
                    quantity = parseInt(numberWord) || numberWords[numberWord];
                    // Remove the number from the array
                    wordsAfterAction.splice(numberIndex, 1);
                }
				// Check if the first word is "a" or "an" and remove it
				if (wordsAfterAction.length > 0 && (wordsAfterAction[0] === 'a' || wordsAfterAction[0] === 'an')) {
					wordsAfterAction.splice(0, 1);
				}

                // Look for unit type (friendly, enemy)
                const unitTypeIndex = wordsAfterAction.findIndex(word => friendlyTerms.includes(word) || enemyTerms.includes(word));
                if (unitTypeIndex !== -1) {
                    const foundAllegianceWord = wordsAfterAction[unitTypeIndex];
                    //Once we detect the allegiance word we'll hard code this to either be friendly or enemy from here on out. To fit later logic which is looking for such.
                    if (friendlyTerms.includes(foundAllegianceWord)) {
                        unitType = 'friendly';
                    } else if (enemyTerms.includes(foundAllegianceWord)) {
                        unitType = 'enemy';
                    } else {
                        //This should never get here, as if it's not in friendlyTerms or enemyTerms it shouldn't get here but to the else statement below
                        //but leaving it for safety. Because the instant you assume it won't get here, some radom edge case will pop up.
                        console.log(`Unknown allegiance: ${foundAllegianceWord}`);
                        statusMessage.textContent += ' (unknown ' + foundAllegianceWord + ' allegiance)';
                        unitType = 'enemy'; // Default to enemy if not recognized
                    }
                    // Remove the unit type from the array
                    wordsAfterAction.splice(unitTypeIndex, 1);
                } else {
                    // Default to enemy if not specified, normally I'd put a message here notifying we didn't find a 'allegiance'
                    // but I think this is a common enough case we don't want to clutter the message.
                    unitType = 'enemy';
                }

                // The remaining words should form the unit name
                unitName = wordsAfterAction.join(' ');
                const mappedName = nameMap[unitName.toLowerCase()];
                if (mappedName) {
                    unitName = mappedName;
                }
                // Now, find the actual unit name from mechData using a case-insensitive search.
                // We search through all the keys in mechData and find the one that matches our
                // unitName regardless of case.
                const foundMechName = Object.keys(mechData).find(key => key.toLowerCase() === unitName.toLowerCase());

                // Now, we check if we found a match.
                if (foundMechName) {
                    // If we found a match, use that key for all subsequent operations.
                    // This preserves the original capitalization from your data.
                    unitName = foundMechName;
                } else {
                    // If no map entry, handle simple pluralization by removing 's'
                    const singularName = unitName.replace(/s$/, '');
                    // Then, normalize the name for lookup
                    unitName = singularName.charAt(0).toUpperCase() + singularName.slice(1);
                }
                
                if (mechData[unitName]) {
                    if (action === 'add') {
                        if (unitType === 'friendly') {
                            friendlyUnits[unitName] = (friendlyUnits[unitName] || 0) + quantity;
                            console.log(`Added ${quantity} friendly units: ${unitName}`);
                        } else if (unitType === 'enemy') {
                            enemyUnits[unitName] = (enemyUnits[unitName] || 0) + quantity;
                            console.log(`Added ${quantity} enemy units: ${unitName}`);
                        }
                    } else if (action === 'remove') {
                        if (unitType === 'friendly' && friendlyUnits[unitName]) {
                            friendlyUnits[unitName] -= quantity;
                            if (friendlyUnits[unitName] <= 0) {
                                delete friendlyUnits[unitName];
                            }
                            console.log(`Removed ${quantity} friendly units: ${unitName}`);
                        } else if (unitType === 'enemy' && enemyUnits[unitName]) {
                            enemyUnits[unitName] -= quantity;
                            if (enemyUnits[unitName] <= 0) {
                                delete enemyUnits[unitName];
                            }
                            console.log(`Removed ${quantity} enemy units: ${unitName}`);
                        }
                    } else {
                        console.log(`Unknown command: ${command}`);
                        statusMessage.textContent += ' (unknown command)';
                    }
                } else {
                    console.log(`Unknown unit: ${unitName}`);
                    statusMessage.textContent += ' (unknown unit)';
                }

                updateUnitsDisplay();
                updateCounterCalculations();
                renderRecommendations();
                renderSynergyRecommendations();
                checkAerialAdvantage(); // Call this new function after processing the command
            };

            /**
             * Initializes and starts the voice recognition service.
             */
            const startVoiceRecognition = () => {
                // Check for browser support
                if (!('webkitSpeechRecognition' in window)) {
                    statusMessage.textContent = 'Voice recognition is not supported in this browser.';
                    toggleButton.disabled = true;
                    return;
                }

                recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                // Event handler for when a command is recognized
                recognition.onresult = (event) => {
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const transcript = event.results[i][0].transcript.trim().toLowerCase();
                        if (event.results[i].isFinal) {
                            processCommand(transcript);
                        }
                    }
                };

                // Event handler for errors
                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    statusMessage.textContent = 'Error: ' + event.error;
                    stopVoiceRecognition();
                };

                // Event handler for when listening stops
                recognition.onend = () => {
                    if (isListening) {
                        console.log('Restarting recognition...');
                        recognition.start();
                    } else {
                        statusMessage.textContent = 'Stopped.';
                        toggleButton.textContent = 'Start Listening';
                    }
                };

                recognition.start();
                isListening = true;
                statusMessage.textContent = 'Listening... ';
                toggleButton.textContent = 'Stop Listening';
                console.log('Voice recognition started.');
            };

            /**
             * Stops the voice recognition service.
             */
            const stopVoiceRecognition = () => {
                if (recognition) {
                    isListening = false;
                    recognition.stop();
                    console.log('Voice recognition stopped.');
                }
            };
            
            // --- EVENT LISTENERS ---
            toggleButton.addEventListener('click', () => {
                if (isListening) {
                    stopVoiceRecognition();
                } else {
                    startVoiceRecognition();
                }
            });

            // Initial UI updates
            updateUnitsDisplay();
            updateCounterCalculations();
            renderRecommendations();
            renderSynergyRecommendations();
            checkAerialAdvantage();
        })();
    </script>
</body>
</html>