<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clearly's Mechabellum Voice Unit Counter Tool</title>
    <!-- Load Tailwind CSS from CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
        }
    </style>
</head>
<body class="flex flex-col items-center p-4">

    <!-- Main Container -->
    <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-2xl w-full relative">
        <!-- Version Number -->
        <span class="absolute top-4 right-4 text-xs text-gray-400">v3.0</span>
        
<h1 class="text-3xl font-bold text-center mb-4 text-sky-400">Clearly's Mechabellum Voice Unit Counter Tool</h1>
        <p class="text-center text-gray-400 mb-4">Try saying "add three friendly crawlers" or "reset counters"</p>

        <!-- Aerial Advantage Warning Banner (Initially Hidden) -->
        <div class="flex justify-center">
            <div id="aerial-warning" class="hidden inline-block bg-yellow-500 text-yellow-900 font-bold py-0.5 px-1 rounded-sm text-xs shadow-md mb-2 transition-all duration-300">
                Warning: <span id="advantage-side"></span> has an aerial advantage!
            </div>
        </div>

        <!-- Control Buttons and Status/Command Display -->
        <div class="flex flex-col md:flex-row items-center justify-center gap-1 mb-4">
            <button id="toggle-voice-btn" class="p-0.5 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow-md transition duration-300 w-full md:w-auto">
                Start Listening
            </button>
            <!-- Single combined element for status and last command, now on the same line -->
            <p id="status-message" class="text-gray-400 italic text-center mt-1 md:mt-0">Press the button to begin.</p>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 gap-1">
            <!-- Enemy Units Display - with red background -->
            <div class="bg-red-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
                <h2 id="enemy-units-title" class="text-large font-semibold mb-1 text-center">Enemy Units: 0</h2>
                <ul id="enemy-units-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-white">Add enemy units via voice.</li>
                </ul>
            </div>

            <!-- Friendly Units Display - with green background -->
            <div class="bg-green-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
                <h2 id="friendly-units-title" class="text-large font-semibold mb-1 text-center">Friendly Units: 0</h2>
                <ul id="friendly-units-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-white">Add friendly units via voice.</li>
                </ul>
            </div>

            <!-- Counter Recommendations Section -->
            <div class="bg-gray-700 p-1 rounded-lg shadow-inner mb-1">
                <h2 class="text-large font-semibold mb-1 text-orange-400">Counter Recommendations ‚öîÔ∏è</h2>
                <ul id="recommendations-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">

                    <li class="text-gray-400">Add enemy units to see counters.</li>
                </ul>
            </div>
            
            <!-- Synergies Recommendations Section -->
            <div id="synergy-recommendations-section" class="bg-gray-700 p-1 rounded-lg shadow-inner mb-1">
                <h2 class="text-large font-semibold mb-1 text-purple-400">Synergy Recommendations ‚ú®</h2>
                <ul id="synergy-recommendations-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-gray-400">Add friendly units to see synergies.</li>
                </ul>
            </div>

            <div class="bg-red-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
			<h3 class="text-sm font-bold mb-1 text-white">Units to Avoid Purchasing üí∏</h3>
			    <ul id="avoid-purchasing-list" class="list-disc pl-5 space-y-1 flex-grow text-sm">
                    <li class="text-gray-400">Add enemy units to see counters.</li>
			</ul>
		</div>

		<!-- Units to Avoid -->
        <div class="bg-gray-700 p-1 rounded-lg shadow-inner flex flex-col text-white">
			<h2 class="text-sm font-semibold text-white mb-1">Your Units Being Countered</h2>
			<ul id="avoid-units-list" class="list-disc pl-5 space-y-2 text-sm">
				<li class="text-gray-400">Add friendly units to see what is being countered.</li>
			</ul>
		</div>
    </div>
        <!-- Footer -->
    <div class="mt-8 text-center text-gray-400 text-xs">
        <p>&copy; 2025 Clearly Misunderstood  || 
        Code available on <a href="https://github.com/dsp6855/Clearly-s-Mechabellum-Voice-Unit-Counter-Tool/tree/main" class="text-indigo-400 hover:underline">GitHub</a></p>

    </div>


    <script>
        // Use an IIFE (Immediately Invoked Function Expression) to avoid global pollution.
        (function() {
		// Check for Web Speech API support
			if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
				// Hide the button and show an error message
				document.getElementById('toggle-voice-btn').style.display = 'none';
				document.getElementById('status-message').textContent = 'Sorry, voice recognition is not supported in this browser.  Try Chrome.';
				document.getElementById('status-message').style.color = '#ffcc00';
				console.error('Web Speech API not supported in this browser.');
				return; // Stop the script from running further
			}
		
            // --- DATA ---
            // A mock mechData object with a "unitCount" and "cost" property.
            const mechData = {
                "Abyss": { "category": ["titan", "air", "ranged", "splash"], "descriptions": "Titan, air, late game, single unit, 100 range, splash, targets air and ground, upkeep cost", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "cost": 800 },
                "Arclight": { "category": ["medium", "ground", "ranged", "splash"], "descriptions": "Medium, ground, anti-swarm, can do anti-air, single unit, splash, 93 range", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 100 },
                "Crawler": { "category": ["light", "ground", "melee"], "descriptions": "light, melee, ground, attacks ground only, 24 units, high speed", "unitCount": 24, "isAirUnit": false, "targets": ["ground"], "cost": 100 },
                "Fang": { "category": ["light", "ground", "ranged"], "descriptions": "light, ground, all-purpose, 18 units, 75 range, targets air and ground, can hide, high speed", "unitCount": 18, "isAirUnit": false, "targets": ["air", "ground"], "cost": 100 },
                "Farseer": { "category": ["large", "ground", "ranged", "splash"], "descriptions": "large, high speed, splash, 125 range, attack air and ground, single unit, rocket", "unitCount": 1, "isAirUnit": false, "targets": ["air", "ground"], "cost": 300 },
                "Fire Badger": { "category": ["medium", "ground", "ranged", "splash"], "descriptions": "medium, anti-swarm tank, splash, 60 range, targets ground only, 3 units", "unitCount": 3, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Fortress": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "giant, high damage, rocket, ground only target, 100 range, splash, slow, high hp, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 400 },
                "Hacker": { "category": ["medium", "ground", "special", "ranged"], "descriptions": "hacker, ground, disables tech, 110 range, high speed", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Hounds": { "category": ["light", "ground", "ranged", "splash"], "descriptions": "high-speed, anti-unit, ground only, 70 range, 5 units", "unitCount": 5, "isAirUnit": false, "targets": ["ground"], "cost": 100 },
                "Marksman": { "category": ["light", "ground", "ranged"], "descriptions": "light, anti-air, targets air and ground, 140 range, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["air", "ground"], "cost": 100 },
                "Melting Point": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "heavy, ground, anti-armor, flame, 115 range, large splash, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["air", "ground"], "cost": 400 },
                "Mountain": { "category": ["titan", "ground", "ranged", "splash"], "descriptions": "giant, high hp, slow, ranged, 100 range, target ground only, 1 units", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 800 },
                "Mustang": { "category": ["light", "ground", "ranged"], "descriptions": "light, mobile, anti-air, targets air and ground, 95 range, 12 units", "unitCount": 12, "isAirUnit": false, "targets": ["air", "ground"], "cost": 200 },
                "Overlord": { "category": ["giant", "air", "ranged", "splash"], "descriptions": "giant, anti-swarm, fire, 120 range, splash, single unit, high hp, fast", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "cost": 500 },
                "Phantom Ray": { "category": ["medium", "air", "ranged", "splash"], "descriptions": "light, air, 65 range, high speed, single unit, splash, targets air and ground, low hp", "unitCount": 3, "isAirUnit": true, "targets": ["air", "ground"], "cost": 200 },
                "Phoenix": { "category": ["medium", "air", "ranged", "splash"], "descriptions": "medium, air, 120 range, targets air and ground, 2 units, splash, high speed", "unitCount": 2, "isAirUnit": true, "targets": ["air", "ground"], "cost": 200 },
                "Raiden": { "category": ["giant", "air", "ranged"], "descriptions": "heavy, ground, 110 range, single unit, targets air and ground, rocket", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "cost": 400 },
                "Rhino": { "category": ["heavy", "ground", "melee", "splash"], "descriptions": "heavy, high hp, ground, anti-armor, single unit, splash", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Sabertooth": { "category": ["heavy", "ground", "ranged"], "descriptions": "heavy, 90 range, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Sandworm": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "giant, ground, splash, single unit, burrow. Can attack air with tech upgrade.", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 400 },
                "Scorpion": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "heavy, anti-swarm, big splsh, high damage, slow speed, target ground only, single unit, 100 range", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 300 },
                "Sledgehammer": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "Heavy Tank, ranged, ground target, splash, slow, 95 range, 5 units", "unitCount": 5, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Steel Ball": { "category": ["medium", "ground", "ranged"], "descriptions": "high-speed, anti-unit, ground only 45 range, attack grows longer attacking, 4 units", "unitCount": 4, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Stormcaller": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "heavy rocket launcher, target ground only, splash, 180 range, 4 units, rockets", "unitCount": 4, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Tarantula": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "heavy, splash, 80 range, fast attack, single unit", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 200 },
                "Typhoon": { "category": ["heavy", "ground", "ranged", "splash"], "descriptions": "heavy, all purpose, splash, quick attack, 100 range, targets air and ground, 2 units", "unitCount": 2, "isAirUnit": false, "targets": ["air", "ground"], "cost": 300 },
                "Void Eye": { "category": ["light", "ground", "special", "ranged"], "descriptions": "light, high damage, 100 range, target ground only, 3 units. Can attack air with tech upgrade.", "unitCount": 3, "isAirUnit": false, "targets": ["ground"], "cost": 100 },
                "Vulcan": { "category": ["giant", "ground", "ranged", "splash"], "descriptions": "giant, anti-swarm, fire, large spash, 95 range,target ground only, single unit, high hp", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 400 },
                "War Factory": { "category": ["titan", "ground", "ranged", "splash"], "descriptions": "titan, produces other units, high hp, expensive, 100 range, targets ground only, splash, slow, upkeep cost", "unitCount": 1, "isAirUnit": false, "targets": ["ground"], "cost": 800 },
                "Wasp": { "category": ["light", "air", "ranged"], "descriptions": "light, air, 12 units, 50 range, high speed, targets air and ground, low HP", "unitCount": 12, "isAirUnit": true, "targets": ["air", "ground"], "cost": 200 },
                "Wraith": { "category": ["heavy", "air", "ranged", "splash"], "descriptions": "heavy, air, single unit, 60 range, splash", "unitCount": 1, "isAirUnit": true, "targets": ["air", "ground"], "cost": 300 }
            };
            
            // This is the correct counters data, replacing the previous duplicate.
            const countersData = {
                "Abyss": { "weakness": ["Marksman", "Melting Point", "Mustang", "Wasp"], "strong_counter": [], "synergizes":[] },
                "Arclight": { "weakness": ["Fortress", "Melting Point", "Overlord", "Rhino", "Scorpion", "Steel Ball", "Stormcaller", "Vulcan", "War Factory"], "strong_counter": ["Crawler", "Hounds", "Mustang", "Stormcaller"], "synergizes":[] },
                "Crawler": { "weakness": ["Arclight", "Fire Badger", "Mustang", "Rhino", "Sledgehammer", "Vulcan", "Wraith"], "strong_counter": ["Hacker", "Marksman", "Melting Point", "Sabertooth", "Steel Ball", "Void Eye"], "synergizes":[] },
                "Fang": { "weakness": ["Fire Badger", "Mustang", "Rhino", "Steel Ball", "Typhoon", "Vulcan", "Wraith"], "strong_counter": ["Fortress", "Hacker", "Marksman", "Mustang", "Phoenix", "Sabertooth", "Stormcaller", "Wasp"], "synergizes":[] },
                "Farseer": { "weakness": ["Fortress", "Melting Point", "Rhino", "War Factory"], "strong_counter": ["Marksman", "Mustang", "Phantom Ray", "Phoenix", "Raiden", "Tarantula"], "synergizes":[] },
                "Fire Badger": { "weakness": ["Fortress", "Overlord", "Rhino", "Sabertooth", "War Factory"], "strong_counter": ["Crawler", "Fang", "Hounds"], "synergizes":[] },
                "Fortress": { "weakness": ["Fang", "Melting Point", "Overlord", "Sandworm", "Steel Ball"], "strong_counter": ["Arclight", "Farseer", "Fire Badger", "Sabertooth", "Stormcaller", "Tarantula", "Typhoon", "Vulcan"], "synergizes":[] },
                "Hacker": { "weakness": ["Crawler", "Fang", "Overlord", "Phoenix", "Stormcaller", "War Factory"], "strong_counter": ["Rhino"], "synergizes":[] },
                "Hounds": { "weakness": ["Arclight", "Fire Badger", "Melting Point", "Overlord", "Rhino", "Scorpion", "Sledgehammer", "Steel Ball", "Tarantula", "Vulcan"], "strong_counter": [], "synergizes":[] },
                "Marksman": { "weakness": ["Crawler", "Fang", "Farseer", "Mustang", "War Factory"], "strong_counter": ["Abyss", "Melting Point", "Phantom Ray", "Phoenix", "Raiden", "Stormcaller", "Tarantula"], "synergizes":[] },
                "Melting Point": { "weakness": ["Crawler", "Marksman", "Phoenix", "Steel Ball"], "strong_counter": ["Abyss", "Arclight", "Farseer", "Fortress", "Hounds", "Mountain", "Overlord", "Raiden", "Rhino", "Sabertooth", "Sandworm", "Tarantula", "Typhoon", "Void Eye", "Vulcan", "War Factory", "Wraith"], "synergizes":[] },
                "Mountain": { "weakness": ["Melting Point", "Overlord", "Rhino", "Scorpion", "Sledgehammer", "Stormcaller", "Tarantula", "Vulcan"], "strong_counter": ["Sandworm"], "synergizes":[] },
                "Mustang": { "weakness": ["Arclight", "Fang", "Farseer", "Overlord", "Phoenix", "Rhino", "Tarantula", "Wasp"], "strong_counter": ["Abyss", "Crawler", "Fang", "Marksman", "Overlord", "Phantom Ray", "Phoenix", "Stormcaller", "Wasp"], "synergizes":[] },
                "Overlord": { "weakness": ["Melting Point", "Mustang", "Phoenix", "Wasp"], "strong_counter": ["Arclight", "Fire Badger", "Fortress", "Hacker", "Hounds", "Mountain", "Mustang", "Raiden", "Rhino", "Scorpion", "Steel Ball", "Sledgehammer", "Stormcaller", "Tarantula", "Vulcan", "War Factory", "Wraith"], "synergizes":[] },
                "Phantom Ray": { "weakness": ["Farseer", "Marksman", "Mustang", "Phoenix", "Raiden", "Typhoon", "Wasp", "Wraith"], "strong_counter": ["Wraith"], "synergizes":[] },
                "Phoenix": { "weakness": ["Fang", "Farseer", "Marksman", "Mustang", "Wasp"], "strong_counter": ["Hacker", "Melting Point", "Mustang", "Overlord", "Phantom Ray", "Raiden", "Rhino", "Scorpion", "Sledgehammer", "Steel Ball", "Tarantula", "Typhoon", "Vulcan"], "synergizes":["Typhoon"] },
                "Raiden": { "weakness": ["Farseer", "Marksman", "Melting Point", "Overlord", "Phoenix"], "strong_counter": ["Phantom Ray", "Wraith"], "synergizes":[] },
                "Rhino": { "weakness": ["Hacker", "Melting Point", "Overlord", "Phoenix", "Steel Ball", "War Factory"], "strong_counter": ["Arclight", "Crawler", "Fang", "Farseer", "Fire Badger", "Hounds", "Mountain", "Mustang", "Void Eye"], "synergizes":[] },
                "Sabertooth": { "weakness": ["Crawler", "Fang", "Fortress", "Melting Point", "Steel Ball", "War Factory"], "strong_counter": ["Fire Badger", "Typhoon"], "synergizes":[] },
                "Sandworm": { "weakness": ["Melting Point", "Mountain", "War Factory"], "strong_counter": ["Fortress"], "synergizes":[] },
                "Scorpion": { "weakness": ["Overlord", "Phoenix", "Wasp"], "strong_counter": ["Arclight", "Hounds", "Mountain", "Typhoon", "Void Eye", "War Factory"], "synergizes":[] },
                "Sledgehammer": { "weakness": ["Phoenix", "Vulcan", "War Factory"], "strong_counter": ["Crawler", "Hounds", "Mountain", "Void Eye"], "synergizes":[] },
                "Steel Ball": { "weakness": ["Crawler", "Overlord", "Phoenix"], "strong_counter": ["Arclight", "Fang", "Fortress", "Hounds", "Melting Point", "Rhino", "Sabertooth", "Tarantula", "Typhoon", "Void Eye", "Vulcan"], "synergizes":[] },
                "Stormcaller": { "weakness": ["Arclight", "Fang", "Fortress", "Marksman", "Mustang", "Overlord", "Typhoon", "Vulcan"], "strong_counter": ["Arclight", "Hacker", "Mountain", "Tarantula"], "synergizes":[] },
                "Tarantula": { "weakness": ["Farseer", "Fortress", "Marksman", "Melting Point", "Overlord", "Phoenix", "Steel Ball", "Stormcaller", "War Factory"], "strong_counter": ["Hounds", "Mountain", "Mustang", "Void Eye"], "synergizes":[] },
                "Typhoon": { "weakness": ["Fortress", "Melting Point", "Phoenix", "Sabertooth", "Scorpion", "Steel Ball", "War Factory"], "strong_counter": ["Fang", "Phantom Ray", "Stormcaller", "Void Eye", "Wraith"], "synergizes":["Phoenix"] },
                "Void Eye": { "weakness": ["Crawler", "Melting Point", "Rhino", "Scorpion", "Sledgehammer", "Steel Ball", "Tarantula", "Typhoon", "Vulcan"], "strong_counter": [], "synergizes":[] },
                "Vulcan": { "weakness": ["Fortress", "Melting Point", "Overlord", "Phoenix", "Steel Ball"], "strong_counter": ["Arclight", "Crawler", "Fang", "Hounds", "Mountain", "Sledgehammer", "Stormcaller", "Void Eye"], "synergizes":[] },
                "War Factory": { "weakness": ["Melting Point", "Overlord", "Scorpion"], "strong_counter": ["Arclight", "Farseer", "Fire Badger", "Hacker", "Marksman", "Rhino", "Sabertooth", "Sandworm", "Sledgehammer", "Tarantula", "Typhoon"], "synergizes":[] },
                "Wasp": { "weakness": ["Fang", "Mustang", "Wraith"], "strong_counter": ["Abyss", "Mustang", "Overlord", "Phantom Ray", "Phoenix", "Scorpion"], "synergizes":[] },
                "Wraith": { "weakness": ["Melting Point", "Overlord", "Phantom Ray", "Raiden", "Typhoon"], "strong_counter": ["Crawler", "Fang", "Phantom Ray", "Wasp"], "synergizes":[] }
            };
            
            // This loop adds each unit to its own weakness array for complete counter logic.
            for (const unit in countersData) {
                if (countersData.hasOwnProperty(unit)) {
                    if (!countersData[unit].weakness.includes(unit)) {
                        countersData[unit].weakness.push(unit);
                    }
                }
            }
            
            // Map for converting spoken numbers to integers
            const numberWords = {
                'one': 1, 'an':1, 'a':1, 'two': 2, 'to':2, 'too':2, 'three': 3, 'through':3, 'four': 4, 'for':4, 'five': 5,
                'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10
            };
            
            // Map for handling common voice recognition misrecognitions or alternate names
            const nameMap = {
				'of this': 'Abyss',
                'a best': 'Abyss',
				'abyss': 'Abyss',
                'abysses': 'Abyss',
                'arc light': 'Arclight',
                'arc lines': 'Arclight',
                'arclights': 'Arclight',
                'arc lights': 'Arclight',
                'crawlers': 'Crawler',
                'crawler': 'Crawler',
                'growler': 'Crawler',
                'growlers': 'Crawler',
                'fangs': 'Fang',
                'things': 'Fang',
                'farseers': 'Farseer',
                'farsier': 'Farseer',
                'farce here': 'Farseer',
                'Farsiers': 'Farseer',
                'Farsier': 'Farseer',
                'fire badger': 'Fire Badger',
                'five Sears': 'Farseer',
                'farts here': 'Farseer',
                'far sear': 'Farseer',
                'fars here': 'Farseer',
                'fortresses': 'Fortress',
				'fortress': 'Fortress',
				'fire badgers': 'Fire Badger',
                'hackers': 'Hacker',
                'hounds': 'Hounds',
                'hound': 'Hounds',
                'hand': 'Hounds',
                'marksmen': 'Marksman',
                'marskmans': 'Marksman',
                'melting points': 'Melting Point', 
                'melting point': 'Melting Point', 
                'melting': 'Melting Point', 
                'mountains': 'Mountain',
                'mustangs': 'Mustang',
                'overlords': 'Overlord',
                'over lords': 'Overlord',
                'over lord': 'Overlord',
                'phantom rays': 'Phantom Ray',
                'phantom ray': 'Phantom Ray',
                'phoenixes': 'Phoenix',
                'raidens': 'Raiden',
                'ratings': 'Raiden',
                'rhinos': 'Rhino',
                'sandworms': 'Sandworm',
                'sand worms': 'Sandworm',
                'sand worm': 'Sandworm',
                'sabertooths': 'Sabertooth',
                'saber tooth': 'Sabertooth',
                'saber tooths': 'Sabertooth',
                'scorpions': 'Scorpion',
                'sledgehammer': 'Sledgehammer',
                'sledgehammers': 'Sledgehammer',
                'sledge hammer': 'Sledgehammer',
                'sledge hammers': 'Sledgehammer',
                'steel balls': 'Steel Ball',
                'steel ball': 'Steel Ball',
                'stool balls': 'Steel Ball',
                'still balls': 'Steel Ball',
                'stormcallers': 'Stormcaller',
                'storm collars': 'Stormcaller',
                'storm coller': 'Stormcaller',
                'storm collars': 'Stormcaller',
                'storm collar': 'Stormcaller',
                'tarantulas': 'Tarantula',
                'thing': 'Fang',
                'typhoons': 'Typhoon',
                'void eyes': 'Void Eye',
                'void eye': 'Void Eye',
                'void I': 'Void Eye',
                'void i': 'Void Eye',
                'vulcans': 'Vulcan',
				'war factory': 'War Factory',
                'war factories': 'War Factory',
                'war factoring': 'War Factory',
                'War Factory': 'War Factory',
                'work Factory': 'War Factory',
                'more Factory': 'War Factory',
                'more factories': 'War Factory',
                'wasps': 'Wasp',
                'wraith': 'Wraith',
                'wraiths': 'Wraith',
                'wraths': 'Wraith'
            };

            const friendlyTerms = ['friendly', 'friend', 'friends', 'our', 'ally', 'allied', 'my', 'me', 'us', 'team'];
            const enemyTerms = ['enemy', 'enemies', 'enemy\'s', 'foe', 'opponent', 'their', 'them', 'opposing', 'opponent\'s', 'opponents'];
            const addTerms = ['ad', 'at', 'bad', 'had', 'i had', 'add', 'give']; //i had being two words is handled at processCommand function.
            const removeTerms = ['remove', 'delete', 'subtract', 'minus', '-', 'take', 'less'];

            // --- STATE ---
            let friendlyUnits = {};
			let enemyUnits = {};
			let isListening = false;
			let recognition = null;
			let finalTranscript = '';
			let lastTranscript = '';

            // --- DOM ELEMENTS ---
            const toggleButton = document.getElementById('toggle-voice-btn');
            const statusMessage = document.getElementById('status-message');
            const friendlyUnitsList = document.getElementById('friendly-units-list');
            const enemyUnitsList = document.getElementById('enemy-units-list');
            const friendlyUnitsTitle = document.getElementById('friendly-units-title');
            const enemyUnitsTitle = document.getElementById('enemy-units-title');
            const recommendationsList = document.getElementById('recommendations-list');
            const aerialWarning = document.getElementById('aerial-warning');
            const advantageSideSpan = document.getElementById('advantage-side');
            const avoidUnitsList = document.getElementById('avoid-units-list'); 
            const synergyRecommendationsList = document.getElementById('synergy-recommendations-list'); 
            const avoidPurchasingList = document.getElementById('avoid-purchasing-list'); 

            // --- FUNCTIONS ---
            /**
             * Updates the displayed lists of friendly and enemy units.
             */
            const updateUnitsDisplay = () => {
                // Clear existing lists
                friendlyUnitsList.innerHTML = '';
                enemyUnitsList.innerHTML = '';

                // Populate friendly units list
                const friendlyUnitNames = Object.keys(friendlyUnits);
                if (friendlyUnitNames.length === 0) {
                    friendlyUnitsList.innerHTML = '<li class="text-white">Add friendly units via voice.</li>';
                } else {
                    friendlyUnitNames.forEach(unit => {
                        const li = document.createElement('li');
                        li.textContent = `${unit.charAt(0).toUpperCase() + unit.slice(1)} x${friendlyUnits[unit]}`;
                        friendlyUnitsList.appendChild(li);
                    });
                }
                
                // Populate enemy units list
                const enemyUnitNames = Object.keys(enemyUnits);
                if (enemyUnitNames.length === 0) {
                    enemyUnitsList.innerHTML = '<li class="text-white">Add enemy units via voice.</li>';
                } else {
                    enemyUnitNames.forEach(unit => {
                        const li = document.createElement('li');
                        li.textContent = `${unit.charAt(0).toUpperCase() + unit.slice(1)} x${enemyUnits[unit]}`;
                        enemyUnitsList.appendChild(li);
                    });
                }
            };
            
            /**
             * Calculates and updates the counter totals.
             */
            const updateCounterCalculations = () => {
                let friendlyUnitGroupsTotal = 0;
                let enemyUnitGroupsTotal = 0;

                // Calculate total counter value for friendly units (count of groups)
                Object.keys(friendlyUnits).forEach(unitName => {
                    const quantity = friendlyUnits[unitName];
                    friendlyUnitGroupsTotal += quantity;
                });
                
                // Calculate total enemy units for display (count of groups)
                Object.keys(enemyUnits).forEach(unitName => {
                    enemyUnitGroupsTotal += enemyUnits[unitName];
                });

                // Update the UI with the totals
                friendlyUnitsTitle.textContent = `Friendly Units: ${friendlyUnitGroupsTotal}`;
                enemyUnitsTitle.textContent = `Enemy Units: ${enemyUnitGroupsTotal}`;
            };
            
            /**
            /**
             * Renders a list of counter recommendations based on the enemy units, sorted by effectiveness and cost.
             */
            const renderRecommendations = () => {
                recommendationsList.innerHTML = ''; // Clear the list

                const enemyUnitNames = Object.keys(enemyUnits);

                if (enemyUnitNames.length === 0) {
                    recommendationsList.innerHTML = '<li class="text-gray-400">Add enemy units to see counters.</li>';
                    return;
                }

                // Create a mutable copy of friendly units to allocate as counters
                const friendlyUnitsToAllocate = { ...friendlyUnits };

                enemyUnitNames.forEach(enemyUnitName => {
                    const weaknesses = countersData[enemyUnitName]?.weakness || [];
                    
                    let friendlyCounterGroups = 0;
                    const counteringUnits = {}; // Use an object to store counts
                    
                    // Find which friendly units are strong counters for this specific enemy unit
                    const potentialCounters = weaknesses.filter(counter => friendlyUnitsToAllocate[counter] > 0);

                    // Sort potential counters by number of groups (descending) to use larger groups first
                    potentialCounters.sort((a, b) => friendlyUnitsToAllocate[b] - friendlyUnitsToAllocate[a]);

                    // Allocate friendly units to counter this enemy unit, consuming them as they are used
                    for (const counter of potentialCounters) {
                        const groupsToAllocate = Math.min(friendlyUnitsToAllocate[counter], enemyUnits[enemyUnitName]);
                        if (groupsToAllocate > 0) {
                            friendlyCounterGroups += groupsToAllocate;
                            counteringUnits[counter] = groupsToAllocate;
                            friendlyUnitsToAllocate[counter] -= groupsToAllocate; // Reduce the available friendly units
                        }
                        if (friendlyCounterGroups >= enemyUnits[enemyUnitName]) {
                            break; // Stop allocating once this enemy unit is fully countered
                        }
                    }

                    const enemyGroups = enemyUnits[enemyUnitName] || 0;
                    const isCountered = friendlyCounterGroups >= enemyGroups;
                    
                    const li = document.createElement('li');
                    li.classList.add('p-2', 'rounded-md', 'mb-2', 'shadow-sm', 'border');
                    
                    let statusText = '';
                    let statusClass = '';

                    if (isCountered) {
                        statusText = 'Countered! ‚úÖ';
                        statusClass = 'bg-green-700 border-green-500';
                        // Build the message string for counters
                        const counteringMessage = Object.keys(counteringUnits).map(unitName => {
                            const quantity = counteringUnits[unitName];
                            return `${quantity} ${unitName.charAt(0).toUpperCase() + unitName.slice(1)}`;
                        }).join(', ');
                        
                        const counterInfo = document.createElement('p');
                        counterInfo.classList.add('text-sm', 'text-gray-300', 'mt-1');
                        counterInfo.textContent = `Countered by: ${counteringMessage}`;
                        li.appendChild(counterInfo);
                    } else {
                        statusText = 'Needs Counters ‚ùå';
                        statusClass = 'bg-red-700 border-red-500';
                        const neededGroups = enemyGroups - friendlyCounterGroups;
                        
                        // Only show recommendations for counters not already in friendly units
                        const unownedCounters = weaknesses.filter(counter => !friendlyUnits[counter] || friendlyUnits[counter] === 0);
                        unownedCounters.sort((a, b) => {
                            const costA = mechData[a]?.cost || Infinity;
                            const costB = mechData[b]?.cost || Infinity;
                            return costA - costB;
                        });
                        
                        // Display the required units to fully counter
                        const counterList = document.createElement('ul');
                        counterList.classList.add('list-disc', 'list-inside', 'text-gray-300', 'ml-4', 'mt-1');
                        
                        if (unownedCounters.length > 0) {
                            const counterLi = document.createElement('li');
                            counterLi.innerHTML = `You need **${neededGroups}** more counter groups. Consider purchasing:`;
                            counterList.appendChild(counterLi);
                            unownedCounters.forEach(counter => {
                                const counterItemLi = document.createElement('li');
                                const cost = mechData[counter]?.cost || 'N/A';
                                counterItemLi.innerHTML = `${counter} (Cost: ${cost})`;
                                counterList.appendChild(counterItemLi);
                            });
                        } else {
                            const counterLi = document.createElement('li');
                            counterLi.classList.add('text-gray-400', 'ml-4', 'italic', 'mt-1');
                            counterLi.textContent = "You have the necessary units but need more groups.";
                            counterList.appendChild(counterLi);
                        }
                        li.appendChild(counterList);
                    }

                    li.innerHTML = `
                        <div class="flex justify-between items-center mb-1">
                            <span class="font-bold text-white">${enemyUnitName.charAt(0).toUpperCase() + enemyUnitName.slice(1)} x${enemyGroups}</span>
                            <span class="text-xs font-semibold px-2 py-0.5 rounded-full ${statusClass}">${statusText}</span>
                        </div>
                        ${li.innerHTML}
                    `;
                    recommendationsList.appendChild(li);
                });

                // --- "Units to Avoid" section ---
                const friendlyUnitNames = Object.keys(friendlyUnits);

                if (friendlyUnitNames.length === 0) {
                    avoidUnitsList.innerHTML = '<li class="text-gray-400">Add friendly units to see which to avoid.</li>';
                } else {
                    const unitsToAvoid = {};
                    friendlyUnitNames.forEach(friendlyUnitName => {
                        Object.keys(enemyUnits).forEach(enemyUnitName => {
                            const enemyWeaknesses = countersData[enemyUnitName]?.weakness || [];
                            if (enemyWeaknesses.includes(friendlyUnitName)) {
                                if (!unitsToAvoid[friendlyUnitName]) {
                                    unitsToAvoid[friendlyUnitName] = [];
                                }
                                if (!unitsToAvoid[friendlyUnitName].includes(enemyUnitName)) {
                                    unitsToAvoid[friendlyUnitName].push(enemyUnitName);
                                }
                            }
                        });
                    });
                    if (Object.keys(unitsToAvoid).length === 0) {
                        avoidUnitsList.innerHTML = '<li class="text-gray-400">No friendly units are weak against enemy units.</li>';
                    } else {
                        const sortedUnitsToAvoid = Object.keys(unitsToAvoid).sort((a, b) => {
                            return unitsToAvoid[b].length - unitsToAvoid[a].length;
                        });
                        
                        const maxCounters = unitsToAvoid[sortedUnitsToAvoid[0]].length;
                        const mostCounteredUnits = sortedUnitsToAvoid.filter(unit => unitsToAvoid[unit].length === maxCounters);

                        avoidUnitsList.innerHTML = '';
                        mostCounteredUnits.forEach(unitToAvoid => {
                            const li = document.createElement('li');
                            li.classList.add('p-2', 'rounded-md', 'mb-2', 'shadow-sm', 'border', 'bg-red-700', 'border-red-500');
                            const counteringUnits = unitsToAvoid[unitToAvoid].join(', ');
                            li.innerHTML = `<span class="font-bold text-white">${unitToAvoid.charAt(0).toUpperCase() + unitToAvoid.slice(1)}</span><span class="text-xs font-semibold px-2 py-0.5 rounded-full bg-red-800 text-white"> weak against: ${counteringUnits}</span>`;
                            avoidUnitsList.appendChild(li);
                        });
                    }
                }

                // --- New section for "Units to Avoid Purchasing" ---
                const allUnits = Object.keys(countersData);
                // --- The "Units to Avoid" section checks your current friendly units and tells you which ones are
                //  weak against the enemy's army. It's about vulnerability you already have on the board.
                const unitsToAvoidPurchasing = {};
                if (enemyUnitNames.length > 0) {
                    allUnits.forEach(unitName => {
                        const unitWeaknesses = countersData[unitName]?.weakness || [];
                        Object.keys(enemyUnits).forEach(enemyUnitName => {
                            if (unitWeaknesses.includes(enemyUnitName)) {
                                if (!unitsToAvoidPurchasing[unitName]) {
                                    unitsToAvoidPurchasing[unitName] = [];
                                }
                                if (!unitsToAvoidPurchasing[unitName].includes(enemyUnitName)) {
                                    unitsToAvoidPurchasing[unitName].push(enemyUnitName);
                                }
                            }
                        });
                    });
                }
                // The "Units to Avoid Purchasing" section, which you pointed out, checks all possible units in the 
                // game and recommends which ones you shouldn't buy because they are weak to the enemy's units.
                const avoidPurchasingList = document.getElementById('avoid-purchasing-list');
                
                if (Object.keys(unitsToAvoidPurchasing).length === 0) {
                    avoidPurchasingList.innerHTML = '<li class="text-gray-400">No units to avoid purchasing against this enemy composition.</li>';
                } else {
                    avoidPurchasingList.innerHTML = '';
                    const sortedAvoidPurchasing = Object.keys(unitsToAvoidPurchasing).sort((a, b) => {
                        const costA = mechData[a]?.cost || Infinity;
                        const costB = mechData[b]?.cost || Infinity;
                        return unitsToAvoidPurchasing[b].length - unitsToAvoidPurchasing[a].length;
                    });
                    
                    sortedAvoidPurchasing.forEach(unitToAvoid => {
                        const li = document.createElement('li');
                        li.classList.add('p-2', 'rounded-md', 'mb-2', 'shadow-sm', 'border', 'bg-red-700', 'border-red-500');
                        const counteringUnits = unitsToAvoidPurchasing[unitToAvoid].join(', ');
                        li.innerHTML = `<span class="font-bold text-white">${unitToAvoid.charAt(0).toUpperCase() + unitToAvoid.slice(1)}</span><span class="text-xs font-semibold px-2 py-0.5 rounded-full bg-red-800 text-white"> weak against: ${counteringUnits}</span>`;
                        avoidPurchasingList.appendChild(li);
                    });
                }
            };
            //
            // synergy recommendations function
            // This function identifies and suggests synergy units that complement the current friendly units
            // without being heavily countered by the enemy composition.
            const renderSynergyRecommendations = () => {
                // Clear any existing recommendations from the list
                synergyRecommendationsList.innerHTML = ''; 
                const friendlyUnitNames = Object.keys(friendlyUnits);

                // If there are no friendly units, display the default message and exit.
                if (friendlyUnitNames.length === 0) {
                    synergyRecommendationsList.innerHTML = '<li class="text-gray-400">Add friendly units to see synergies.</li>';
                    return;
                }

                const recommendations = {};

                // First Pass: Find all potential synergy units based on friendly units.
                friendlyUnitNames.forEach(friendlyUnitName => {
                    // SOLUTION: Use a case-insensitive lookup to find the correct key.
                    const dataKey = Object.keys(countersData).find(key => key.toLowerCase() === friendlyUnitName.toLowerCase());
                    if (!dataKey) return; // If no match is found, skip this unit.

                    const synergies = countersData[dataKey]?.synergizes || [];

                    synergies.forEach(synergyUnitName => {
                        // Initialize the recommendation object for a new synergy unit if it doesn't exist.
                        if (!recommendations[synergyUnitName]) {
                            recommendations[synergyUnitName] = {
                                synergizingWith: [],
                                isCountered: false
                            };
                        }
                        // Add the current friendly unit to the list of units that synergize with this recommendation.
                        recommendations[synergyUnitName].synergizingWith.push(friendlyUnitName);
                    });
                });
                
                // If no synergies were found after the first pass, display a message and exit.
                if (Object.keys(recommendations).length === 0) {
                    synergyRecommendationsList.innerHTML = '<li class="text-gray-400">No synergy recommendations at this time.</li>';
                    return;
                }

                // Second Pass: Iterate through the compiled recommendations, check for enemy counters, and render the final list.
                Object.keys(recommendations).forEach(synergyUnit => {
                    const synergyData = recommendations[synergyUnit];
                    
                    // Check if this synergy unit is countered by any of the enemy units.
                    // SOLUTION: Use a case-insensitive lookup here as well.
                    const dataKey = Object.keys(countersData).find(key => key.toLowerCase() === synergyUnit.toLowerCase());
                    if (!dataKey) return;
                    
                    const enemyCounters = countersData[dataKey]?.weakness || [];
                    const isCountered = enemyCounters.some(counterUnit => {
                        // This check now uses a case-insensitive comparison
                        return Object.keys(enemyUnits).some(enemyKey => enemyKey.toLowerCase() === counterUnit.toLowerCase());
                    });
                    synergyData.isCountered = isCountered;
                    
                    const li = document.createElement('li');
                    
                    let statusText = '';
                    let statusClass = '';
                    if (synergyData.isCountered) {
                         statusText = 'Caution ‚ö†Ô∏è';
                         statusClass = 'bg-yellow-700 text-yellow-200 border-yellow-500';
                    } else {
                        statusText = 'Strong Syngery ‚úÖ';
                        statusClass = 'bg-purple-700 text-purple-200 border-purple-500';
                    }

                    li.classList.add('p-1', 'rounded-md', 'mb-1', 'shadow-sm', 'border', ...statusClass.split(' '));
                    const synergizingWith = synergyData.synergizingWith.map(unit => {
                        // SOLUTION: This line now uses a case-insensitive lookup to get the correct friendly unit count.
                        const friendlyKey = Object.keys(friendlyUnits).find(key => key.toLowerCase() === unit.toLowerCase());
                        const friendlyCount = friendlyUnits[friendlyKey] || 0;
                        return `${friendlyKey.charAt(0).toUpperCase() + friendlyKey.slice(1)} x${friendlyCount}`;
                    }).join(', ');
                    
                    // Construct the inner HTML of the list item.
                    const synergyHtml = `
                        <div class="flex justify-between items-center mb-0">
                            <span class="font-bold text-white">${synergyUnit.charAt(0).toUpperCase() + synergyUnit.slice(1)}</span>
                            <span class="text-xs font-semibold px-2 py-0.5 rounded-full ${statusClass}">${statusText}</span>
                        </div>
                        <p class="text-xs text-gray-300">Synergizes with: ${synergizingWith}</p>
                    `;

                    li.innerHTML = synergyHtml;
                    // Append the newly created and populated list item to the recommendations list.
                    synergyRecommendationsList.appendChild(li);
                });
            };
            //
            // end of synergy function
            //
            /**
             * Checks for and displays warnings related to aerial advantage.
             */
            const checkAerialAdvantage = () => {
                let friendlyAirUnits = false;
                let friendlyAntiAirUnits = false;
                let enemyAirUnits = false;
                let enemyAntiAirUnits = false;
                const aerialWarning = document.getElementById('aerial-warning');
                const advantageSideSpan = document.getElementById('advantage-side');
                
                // Check friendly units for air and anti-air capability
                for (const unit in friendlyUnits) {
                    if (mechData[unit]?.isAirUnit) {
                        friendlyAirUnits = true;
                    }
                    if (mechData[unit]?.targets.includes("air")) {
                        friendlyAntiAirUnits = true;
                    }
                }

                // Check enemy units for air and anti-air capability
                for (const unit in enemyUnits) {
                    if (mechData[unit]?.isAirUnit) {
                        enemyAirUnits = true;
                    }
                    if (mechData[unit]?.targets.includes("air")) {
                        enemyAntiAirUnits = true;
                    }
                }
                
                // Reset visibility for the main aerial advantage banner
                aerialWarning.classList.add('hidden');

                // Condition 1: Check for a clear aerial advantage (e.g., air units with no opposing anti-air)
                if (friendlyAirUnits && !enemyAntiAirUnits) {
                    advantageSideSpan.textContent = 'Friendly Side';
                    aerialWarning.classList.remove('hidden');
                } else if (enemyAirUnits && !friendlyAntiAirUnits) {
                    advantageSideSpan.textContent = 'Enemy Side';
                    aerialWarning.classList.remove('hidden');
                }

                // The fix is here: The message is added to the statusMessage div, but only
                // if there are enemy units present.
                if (Object.keys(enemyUnits).length > 0 && !enemyAntiAirUnits) {
                    statusMessage.innerHTML += ' <br><span class="text-yellow-400 text-xs">(Enemy has no anti-air, consider adding air units!)</span>';
                }
            };
            // end of aerial advantage function

            /**
             * Processes a recognized voice command to add or remove a unit.
             */
            const processCommand = (command) => {
                // Convert the entire command to lowercase to handle case variations.
                const commandLower = command.toLowerCase();
                const commandWords = commandLower.split(' ');
                let action = '';
                let unitType = '';
                let unitName = '';
                let quantity = 1;
                let commandSplice=1;    

                // Handle the reset command first as a special case
                if (commandLower.trim() === 'reset counters') {
                    friendlyUnits = {};
                    enemyUnits = {};
                    updateUnitsDisplay();
                    updateCounterCalculations();
                    renderRecommendations();
                    renderSynergyRecommendations();
                    checkAerialAdvantage();
                    statusMessage.textContent = 'Counters have been reset.';
                    console.log('Counters have been reset.');
                    return;
                }

                // Update the last command display
                statusMessage.textContent = `Command: "${command}"`;
                // Check for action (add, remove)
                action = commandWords[0];
                if (action==='i') { action += ' ' + commandWords[1]; } // Handle "I had" case 
                // Handle common misrecognitions for "add"
                if (addTerms.includes(action)) {
                    action = 'add';
                    // splice off 2 words if the action is "i had"
                    if (commandWords[0].toLowerCase()==='i' && commandWords[1].toLowerCase()==='had') {
                        commandSplice=2; // If the action word is actually two words, remove both from the unit name search
                        action = 'add';
                 }
                // Handle synonyms for removing a unit
                } else if (removeTerms.includes(action)) {
                    action = 'remove';  
                // Default to add if no valid action is found, idea is this is the most common command
                } else {
                    console.log(`Unknown action: ${action}`);
                    
                    statusMessage.textContent += ' (' + action + ' unknown action)';
                    action = 'add'; 
                    commandSplice=0; // If no action word, don't remove the first word as it might be part of the unit name
                }

                // Find the quantity and unit type
                let wordsAfterAction = commandWords.slice(commandSplice);
                
                // Look for a number word or digit
                const numberIndex = wordsAfterAction.findIndex(word => !isNaN(parseInt(word)) || numberWords[word]);
                if (numberIndex !== -1) {
                    const numberWord = wordsAfterAction[numberIndex];
                    quantity = parseInt(numberWord) || numberWords[numberWord];
                    // Remove the number from the array
                    wordsAfterAction.splice(numberIndex, 1);
                }
				// Check if the first word is "a" or "an" and remove it
				if (wordsAfterAction.length > 0 && (wordsAfterAction[0] === 'a' || wordsAfterAction[0] === 'an')) {
					wordsAfterAction.splice(0, 1);
				}

                // Look for unit type (friendly, enemy)
                const unitTypeIndex = wordsAfterAction.findIndex(word => friendlyTerms.includes(word) || enemyTerms.includes(word));
                if (unitTypeIndex !== -1) {
                    const foundAllegianceWord = wordsAfterAction[unitTypeIndex];
                    //Once we detect the allegiance word we'll hard code this to either be friendly or enemy from here on out. To fit later logic which is looking for such.
                    if (friendlyTerms.includes(foundAllegianceWord)) {
                        unitType = 'friendly';
                    } else if (enemyTerms.includes(foundAllegianceWord)) {
                        unitType = 'enemy';
                    } else {
                        //This should never get here, as if it's not in friendlyTerms or enemyTerms it shouldn't get here but to the else statement below
                        //but leaving it for safety. Because the instant you assume it won't get here, some radom edge case will pop up.
                        console.log(`Unknown allegiance: ${foundAllegianceWord}`);
                        statusMessage.textContent += ' (unknown ' + foundAllegianceWord + ' allegiance)';
                        unitType = 'enemy'; // Default to enemy if not recognized
                    }
                    // Remove the unit type from the array
                    wordsAfterAction.splice(unitTypeIndex, 1);
                } else {
                    // Default to enemy if not specified, normally I'd put a message here notifying we didn't find a 'allegiance'
                    // but I think this is a common enough case we don't want to clutter the message.
                    unitType = 'enemy';
                }

                // The remaining words should form the unit name
                unitName = wordsAfterAction.join(' ');
                // Now, find the actual unit name from mechData using a case-insensitive search.
                // We search through all the keys in mechData and find the one that matches our
                // unitName regardless of case.
                const foundMechName = Object.keys(mechData).find(key => key.toLowerCase() === unitName.toLowerCase());

                // Now, we check if we found a match.
                if (foundMechName) {
                    // If we found a match, use that key for all subsequent operations.
                    // This preserves the original capitalization from your data.
                    unitName = foundMechName;
                } else {
                    // If no map entry, handle simple pluralization by removing 's'
                    const singularName = unitName.replace(/s$/, '');
                    // Then, normalize the name for lookup
                    unitName = singularName.charAt(0).toUpperCase() + singularName.slice(1);
                }
                
                if (mechData[unitName]) {
                    if (action === 'add') {
                        if (unitType === 'friendly') {
                            friendlyUnits[unitName] = (friendlyUnits[unitName] || 0) + quantity;
                            console.log(`Added ${quantity} friendly units: ${unitName}`);
                        } else if (unitType === 'enemy') {
                            enemyUnits[unitName] = (enemyUnits[unitName] || 0) + quantity;
                            console.log(`Added ${quantity} enemy units: ${unitName}`);
                        }
                    } else if (action === 'remove') {
                        if (unitType === 'friendly' && friendlyUnits[unitName]) {
                            friendlyUnits[unitName] -= quantity;
                            if (friendlyUnits[unitName] <= 0) {
                                delete friendlyUnits[unitName];
                            }
                            console.log(`Removed ${quantity} friendly units: ${unitName}`);
                        } else if (unitType === 'enemy' && enemyUnits[unitName]) {
                            enemyUnits[unitName] -= quantity;
                            if (enemyUnits[unitName] <= 0) {
                                delete enemyUnits[unitName];
                            }
                            console.log(`Removed ${quantity} enemy units: ${unitName}`);
                        }
                    } else {
                        console.log(`Unknown command: ${command}`);
                        statusMessage.textContent += ' (unknown command)';
                    }
                } else {
                    console.log(`Unknown unit: ${unitName}`);
                    statusMessage.textContent += ' (unknown unit)';
                }

                updateUnitsDisplay();
                updateCounterCalculations();
                renderRecommendations();
                renderSynergyRecommendations();
                checkAerialAdvantage(); // Call this new function after processing the command
            };

            /**
             * Initializes and starts the voice recognition service.
             */
            const startVoiceRecognition = () => {
                // Check for browser support
                if (!('webkitSpeechRecognition' in window)) {
                    statusMessage.textContent = 'Voice recognition is not supported in this browser.';
                    toggleButton.disabled = true;
                    return;
                }

                recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                // Event handler for when a command is recognized
                recognition.onresult = (event) => {
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const transcript = event.results[i][0].transcript.trim().toLowerCase();
                        if (event.results[i].isFinal) {
                            processCommand(transcript);
                        }
                    }
                };

                // Event handler for errors
                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    statusMessage.textContent = 'Error: ' + event.error;
                    stopVoiceRecognition();
                };

                // Event handler for when listening stops
                recognition.onend = () => {
                    if (isListening) {
                        console.log('Restarting recognition...');
                        recognition.start();
                    } else {
                        statusMessage.textContent = 'Stopped.';
                        toggleButton.textContent = 'Start Listening';
                    }
                };

                recognition.start();
                isListening = true;
                statusMessage.textContent = 'Listening... ';
                toggleButton.textContent = 'Stop Listening';
                console.log('Voice recognition started.');
            };

            /**
             * Stops the voice recognition service.
             */
            const stopVoiceRecognition = () => {
                if (recognition) {
                    isListening = false;
                    recognition.stop();
                    console.log('Voice recognition stopped.');
                }
            };
            
            // --- EVENT LISTENERS ---
            toggleButton.addEventListener('click', () => {
                if (isListening) {
                    stopVoiceRecognition();
                } else {
                    startVoiceRecognition();
                }
            });

            // Initial UI updates
            updateUnitsDisplay();
            updateCounterCalculations();
            renderRecommendations();
            renderSynergyRecommendations();
            checkAerialAdvantage();
        })();
    </script>
</body>
</html>